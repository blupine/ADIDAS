{"best matching": [{"ea": "00401d80", "origin name": "frame_dummy", "ea2": "004024c0", "matched name": "frame_dummy", "ratio": "1.000", "bb1": "7", "bb2": "7", "heuristic": "Equal pseudo-code", "pseudo": ["__int64 frame_dummy()\n{\n  if ( _register_frame_info )\n    _register_frame_info(&_EH_FRAME_BEGIN__, &object_6475);\n  return register_tm_clones();\n}", "__int64 frame_dummy()\n{\n  if ( _register_frame_info )\n    _register_frame_info(&_EH_FRAME_BEGIN__, &object_6475);\n  return register_tm_clones();\n}"], "asm": ["push    rbp\nmov     eax, offset __register_frame_info\ntest    rax, rax\nmov     rbp, rsp\njz      short loc_401D9D\nloc_401d10:\nmov     eax, offset _edata\nloc_401d8e:\nmov     esi, offset object_6475\nmov     edi, offset __EH_FRAME_BEGIN__\ncall    __register_frame_info\nloc_401d9d:\ncmp     cs:__JCR_LIST__, 0\njz      short loc_401DB8\nloc_401da7:\nmov     eax, 0\ntest    rax, rax\njz      short loc_401DB8\nloc_401db1:\nmov     edi, offset __JCR_LIST__\ncall    rax\nloc_401db8:\npop     rbp\njmp     register_tm_clones", "push    rbp\nmov     eax, offset __register_frame_info\ntest    rax, rax\nmov     rbp, rsp\njz      short loc_4024DD\nloc_402450:\nmov     eax, offset _edata\nloc_4024ce:\nmov     esi, offset object_6475\nmov     edi, offset __EH_FRAME_BEGIN__\ncall    __register_frame_info\nloc_4024dd:\ncmp     cs:__JCR_LIST__, 0\njz      short loc_4024F8\nloc_4024e7:\nmov     eax, 0\ntest    rax, rax\njz      short loc_4024F8\nloc_4024f1:\nmov     edi, offset __JCR_LIST__\ncall    rax\nloc_4024f8:\npop     rbp\njmp     register_tm_clones"]}, {"ea": "00401cae", "origin name": "_start", "ea2": "004023ee", "matched name": "_start", "ratio": "1.000", "bb1": "1", "bb2": "1", "heuristic": "Equal assembly", "pseudo": ["None\nNone", "None\nNone"], "asm": ["xor     ebp, ebp\nmov     r9, rdx; rtld_fini\npop     rsi; argc\nmov     rdx, rsp; ubp_av\nand     rsp, 0FFFFFFFFFFFFFFF0h\npush    rax\npush    rsp; stack_end\nmov     r8, offset __libc_csu_fini; fini\nmov     rcx, offset __libc_csu_init; init\nmov     rdi, offset main; main\ncall    __libc_start_main", "xor     ebp, ebp\nmov     r9, rdx; rtld_fini\npop     rsi; argc\nmov     rdx, rsp; ubp_av\nand     rsp, 0FFFFFFFFFFFFFFF0h\npush    rax\npush    rsp; stack_end\nmov     r8, offset __libc_csu_fini; fini\nmov     rcx, offset __libc_csu_init; init\nmov     rdi, offset main; main\ncall    __libc_start_main"]}, {"ea": "00401a20", "origin name": "fini", "ea2": "00401a20", "matched name": "fini", "ratio": "1.000", "bb1": "5", "bb2": "5", "heuristic": "Same address, nodes, edges and mnemonics", "pseudo": ["void __fastcall fini(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)\n{\n  if ( qword_6FF038 )\n  {\n    if ( memcmp((const void *)qword_6FF038, \"out of memory\", 0xEuLL) )\n      free(qword_6FF038);\n  }\n}", "void fini()\n{\n  if ( qword_6FBFB8 )\n  {\n    if ( memcmp(qword_6FBFB8, \"out of memory\", 0xEuLL) )\n      free(qword_6FBFB8);\n  }\n}"], "asm": ["mov     rax, cs:qword_6FF038\ntest    rax, rax\njz      short locret_401A3D\nloc_401a2c:\nmov     edi, offset _dl_out_of_memory; \"out of memory\"\nmov     ecx, 0Eh\nmov     rsi, rax\nrepe cmpsb\njnz     short loc_401A3E\nloc_401a3d:\nretn\nloc_401a3e:\nmov     rdi, rax\njmp     free\nloc_42da90:\nmov     rax, cs:__free_hook", "mov     rax, cs:qword_6FBFB8\ntest    rax, rax\njz      short locret_401A3D\nloc_401a2c:\nmov     edi, offset _dl_out_of_memory; \"out of memory\"\nmov     ecx, 0Eh\nmov     rsi, rax\nrepe cmpsb\njnz     short loc_401A3E\nloc_401a3d:\nretn\nloc_401a3e:\nmov     rdi, rax; void *\njmp     free\nloc_429bd0:\nmov     rax, cs:__free_hook"]}, {"ea": "00401a50", "origin name": "init_cacheinfo", "ea2": "00402190", "matched name": "init_cacheinfo", "ratio": "1.000", "bb1": "41", "bb2": "41", "heuristic": "Same constants", "pseudo": ["__int64 __fastcall init_cacheinfo(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)\n{\n  __int64 result; // rax\n  signed __int64 v9; // r12\n  double v10; // xmm4_8\n  double v11; // xmm5_8\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  signed __int64 v14; // rbp\n  signed int v15; // er8\n  int i; // ecx\n  int v17; // edi\n  __int64 v22; // r11\n  signed __int64 v23; // rax\n  signed __int64 v24; // rax\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  double v27; // xmm4_8\n  double v28; // xmm5_8\n  signed __int64 v29; // rdi\n  unsigned int v34; // esi\n  __int64 v39; // rbx\n  unsigned int v49; // esi\n  int j; // ecx\n  int v51; // edi\n  int v56; // ecx\n  int v57; // ecx\n\n  result = (unsigned int)_cpu_features;\n  if ( !_cpu_features )\n  {\n    _init_cpu_features();\n    result = (unsigned int)_cpu_features;\n  }\n  if ( (_DWORD)result == 1 )\n  {\n    v9 = handle_intel(188, dword_6FF964, a1, a2, a3, a4, a5, a6, a7, a8);\n    result = handle_intel(194, dword_6FF964, a1, a2, a3, a4, v10, v11, a7, a8);\n    v14 = result;\n    v15 = 3;\n    if ( result <= 0 )\n    {\n      result = handle_intel(191, dword_6FF964, a1, a2, a3, a4, v12, v13, a7, a8);\n      v15 = 2;\n      v14 = result;\n    }\n    if ( dword_6FF964 > 3 )\n    {\n      for ( i = 0; ; i = v17 )\n      {\n        v17 = i + 1;\n        _RAX = 4LL;\n        __asm { cpuid }\n        if ( !(result & 0x1F) )\n          break;\n        if ( (unsigned __int8)result >> 5 == v15 )\n        {\n          result = (unsigned int)result >> 14;\n          v49 = result & 0x3FF;\n          if ( result & 0x3FF && dword_6FF964 > 10 )\n          {\n            for ( j = 0; ; j = v51 )\n            {\n              v51 = j + 1;\n              _RAX = 11LL;\n              __asm { cpuid }\n              v56 = _RCX & 0xFF0;\n              if ( !v56 || !(_BYTE)_RBX )\n                break;\n              if ( v56 == 512 )\n              {\n                _BitScanReverse((unsigned int *)&v57, v49);\n                v49 = ((unsigned __int8)_RBX - 1) & ~(-1 << (v57 + 1));\n                break;\n              }\n            }\n          }\n          v22 = v49 + 1;\n          goto LABEL_14;\n        }\n      }\n    }\n    v22 = BYTE2(dword_6FF96C);\nLABEL_14:\n    if ( (_DWORD)v22 && v14 > 0 )\n    {\n      result = v14 / v22;\n      v14 /= v22;\n    }\n    goto LABEL_17;\n  }\n  if ( (_DWORD)result != 2 )\n    return result;\n  v9 = handle_amd(188, a1, a2, a3, a4, a5, a6, a7, a8);\n  v14 = handle_amd(191, a1, a2, a3, a4, v25, v26, a7, a8);\n  v29 = handle_amd(194, a1, a2, a3, a4, v27, v28, a7, a8);\n  _RAX = 0x80000000LL;\n  __asm { cpuid }\n  v34 = result;\n  if ( v29 > 0 )\n  {\n    if ( (unsigned int)result > 0x80000007 )\n    {\n      _RAX = 2147483656LL;\n      __asm { cpuid }\n      v34 = _RAX;\n      v39 = (unsigned int)(1 << ((unsigned __int16)_RCX >> 12));\n    }\n    else\n    {\n      _RAX = 1LL;\n      __asm { cpuid }\n      v34 = result;\n      if ( !(_RDX & 0x10000000) )\n        goto LABEL_25;\n      v39 = BYTE2(_RBX);\n      if ( !(_DWORD)v39 )\n        goto LABEL_25;\n    }\n    result = v29 / v39;\n    v29 /= v39;\nLABEL_25:\n    v14 += v29;\n  }\n  if ( v34 > 0x80000000 )\n  {\n    _RAX = 2147483649LL;\n    __asm { cpuid }\n    if ( _RCX & 0x100 || (signed int)_RDX < 0 )\n      _x86_prefetchw = -1;\n  }\nLABEL_17:\n  if ( v9 > 0 )\n  {\n    v23 = v9;\n    _x86_raw_data_cache_size = v9;\n    LOBYTE(v9) = 0;\n    _x86_data_cache_size = v9;\n    _x86_raw_data_cache_size_half = v23 >> 1;\n    result = v9 >> 1;\n    _x86_data_cache_size_half = v9 >> 1;\n  }\n  if ( v14 > 0 )\n  {\n    v24 = v14;\n    _x86_raw_shared_cache_size = v14;\n    LOBYTE(v14) = 0;\n    _x86_shared_cache_size = v14;\n    _x86_raw_shared_cache_size_half = v24 >> 1;\n    result = v14 >> 1;\n    _x86_shared_cache_size_half = v14 >> 1;\n  }\n  return result;\n}", "__int64 init_cacheinfo()\n{\n  __int64 result; // rax\n  __int64 v1; // r12\n  __int64 v2; // rbp\n  signed int v3; // er8\n  int i; // ecx\n  int v5; // edi\n  __int64 v10; // r11\n  __int64 v11; // rax\n  __int64 v12; // rax\n  __int64 v13; // rdi\n  unsigned int v18; // esi\n  __int64 v23; // rbx\n  int v33; // esi\n  int j; // ecx\n  int v35; // edi\n  int v40; // ecx\n  int v41; // ecx\n\n  result = (unsigned int)_cpu_features;\n  if ( !_cpu_features )\n  {\n    _init_cpu_features();\n    result = (unsigned int)_cpu_features;\n  }\n  if ( (_DWORD)result == 1 )\n  {\n    v1 = handle_intel(188LL, (unsigned int)dword_6FC8E4);\n    result = handle_intel(194LL, (unsigned int)dword_6FC8E4);\n    v2 = result;\n    v3 = 3;\n    if ( result <= 0 )\n    {\n      result = handle_intel(191LL, (unsigned int)dword_6FC8E4);\n      v3 = 2;\n      v2 = result;\n    }\n    if ( dword_6FC8E4 > 3 )\n    {\n      for ( i = 0; ; i = v5 )\n      {\n        v5 = i + 1;\n        _RAX = 4LL;\n        __asm { cpuid }\n        if ( !(result & 0x1F) )\n          break;\n        if ( (unsigned __int8)result >> 5 == v3 )\n        {\n          result = (unsigned int)result >> 14;\n          v33 = result & 0x3FF;\n          if ( result & 0x3FF && dword_6FC8E4 > 10 )\n          {\n            for ( j = 0; ; j = v35 )\n            {\n              v35 = j + 1;\n              _RAX = 11LL;\n              __asm { cpuid }\n              v40 = _RCX & 0xFF0;\n              if ( !v40 || !(_BYTE)_RBX )\n                break;\n              if ( v40 == 512 )\n              {\n                _BitScanReverse((unsigned int *)&v41, v33);\n                v33 = ((unsigned __int8)_RBX - 1) & ~(-1 << (v41 + 1));\n                break;\n              }\n            }\n          }\n          v10 = (unsigned int)(v33 + 1);\n          goto LABEL_14;\n        }\n      }\n    }\n    v10 = BYTE2(dword_6FC8EC);\nLABEL_14:\n    if ( (_DWORD)v10 && v2 > 0 )\n    {\n      result = v2 / v10;\n      v2 /= v10;\n    }\n    goto LABEL_17;\n  }\n  if ( (_DWORD)result != 2 )\n    return result;\n  v1 = handle_amd(188LL);\n  v2 = handle_amd(191LL);\n  v13 = handle_amd(194LL);\n  _RAX = 0x80000000LL;\n  __asm { cpuid }\n  v18 = result;\n  if ( v13 > 0 )\n  {\n    if ( (unsigned int)result > 0x80000007 )\n    {\n      _RAX = 2147483656LL;\n      __asm { cpuid }\n      v18 = _RAX;\n      v23 = (unsigned int)(1 << ((unsigned __int16)_RCX >> 12));\n    }\n    else\n    {\n      _RAX = 1LL;\n      __asm { cpuid }\n      v18 = result;\n      if ( !(_RDX & 0x10000000) )\n        goto LABEL_25;\n      v23 = BYTE2(_RBX);\n      if ( !(_DWORD)v23 )\n        goto LABEL_25;\n    }\n    result = v13 / v23;\n    v13 /= v23;\nLABEL_25:\n    v2 += v13;\n  }\n  if ( v18 > 0x80000000 )\n  {\n    _RAX = 2147483649LL;\n    __asm { cpuid }\n    if ( _RCX & 0x100 || (signed int)_RDX < 0 )\n      _x86_prefetchw = -1;\n  }\nLABEL_17:\n  if ( v1 > 0 )\n  {\n    v11 = v1;\n    _x86_raw_data_cache_size = v1;\n    LOBYTE(v1) = 0;\n    _x86_data_cache_size = v1;\n    _x86_raw_data_cache_size_half = v11 >> 1;\n    result = v1 >> 1;\n    _x86_data_cache_size_half = v1 >> 1;\n  }\n  if ( v2 > 0 )\n  {\n    v12 = v2;\n    _x86_raw_shared_cache_size = v2;\n    LOBYTE(v2) = 0;\n    _x86_shared_cache_size = v2;\n    _x86_raw_shared_cache_size_half = v12 >> 1;\n    result = v2 >> 1;\n    _x86_shared_cache_size_half = v2 >> 1;\n  }\n  return result;\n}"], "asm": ["push    r12\nmov     eax, cs:__cpu_features\npush    rbp\ntest    eax, eax\npush    rbx\njz      short loc_401A71\nloc_401a5e:\ncmp     eax, 1\njz      short loc_401A7E\nloc_401a63:\ncmp     eax, 2\njz      loc_401B81\nloc_401a6c:\npop     rbx\npop     rbp\npop     r12\nretn\nloc_401a71:\ncall    __init_cpu_features\nmov     eax, cs:__cpu_features\njmp     short loc_401A5E\nloc_401a7e:\nmov     esi, cs:dword_6FF964\nmov     edi, 0BCh\ncall    handle_intel\nmov     esi, cs:dword_6FF964\nmov     edi, 0C2h\nmov     r12, rax\ncall    handle_intel\ntest    rax, rax\nmov     rbp, rax\nmov     r8d, 3\njle     loc_401C7C\nloc_401ab3:\nmov     r10d, cs:dword_6FF964\nmov     r11d, cs:dword_6FF96C\ncmp     r10d, 3\njle     short loc_401AF7\nloc_401ac7:\nxor     ecx, ecx\nmov     r9d, 4\njmp     short loc_401AEB\nloc_401ad8:\nmov     edx, eax\nshr     edx, 5\nand     edx, 7\ncmp     edx, r8d\njz      loc_401C35\nloc_401ae9:\nmov     ecx, edi\nloc_401aeb:\nlea     edi, [rcx+1]\nmov     eax, r9d\ncpuid\ntest    al, 1Fh\njnz     short loc_401AD8\nloc_401af7:\nshr     r11d, 10h\nmovzx   r11d, r11b\nloc_401aff:\ntest    r11d, r11d\njz      short loc_401B09\nloc_401b04:\ntest    rbp, rbp\njg      short loc_401B74\nloc_401b09:\ntest    r12, r12\njle     short loc_401B3A\nloc_401b0e:\nmov     rax, r12\nmov     cs:__x86_raw_data_cache_size, r12\nand     r12b, 0\nsar     rax, 1\nmov     cs:__x86_data_cache_size, r12\nmov     cs:__x86_raw_data_cache_size_half, rax\nmov     rax, r12\nsar     rax, 1\nmov     cs:__x86_data_cache_size_half, rax\nloc_401b3a:\ntest    rbp, rbp\njle     loc_401A6C\nloc_401b43:\nmov     rax, rbp\nmov     cs:__x86_raw_shared_cache_size, rbp\nand     bpl, 0\nsar     rax, 1\nmov     cs:__x86_shared_cache_size, rbp\npop     rbx\nmov     cs:__x86_raw_shared_cache_size_half, rax\nmov     rax, rbp\nsar     rax, 1\npop     rbp\nmov     cs:__x86_shared_cache_size_half, rax\npop     r12\nretn\nloc_401b74:\nmov     rax, rbp\ncqo\nidiv    r11\nmov     rbp, rax\njmp     short loc_401B09\nloc_401b81:\nmov     edi, 0BCh\ncall    handle_amd\nmov     edi, 0BFh\nmov     r12, rax\ncall    handle_amd\nmov     edi, 0C2h\nmov     rbp, rax\ncall    handle_amd\nmov     esi, 80000000h\nmov     rdi, rax\nmov     eax, esi\ncpuid\ntest    rdi, rdi\nmov     esi, eax\njle     short loc_401BDF\nloc_401bb8:\ncmp     eax, 80000007h\nja      short loc_401C06\nloc_401bbf:\nmov     esi, 1\nmov     eax, esi\ncpuid\nand     edx, 10000000h\nmov     esi, eax\njz      short loc_401BDC\nloc_401bd2:\nshr     ebx, 10h\nmovzx   ebx, bl\ntest    ebx, ebx\njnz     short loc_401C1E\nloc_401bdc:\nadd     rbp, rdi\nloc_401bdf:\ncmp     esi, 80000000h\njbe     loc_401B09\nloc_401beb:\nmov     eax, 80000001h\ncpuid\nand     ch, 1\njz      short loc_401C2B\nloc_401bf7:\nmov     cs:__x86_prefetchw, 0FFFFFFFFh\njmp     loc_401B09\nloc_401c06:\nmov     esi, 80000008h\nmov     eax, esi\ncpuid\nshr     ecx, 0Ch\nmov     ebx, 1\nmov     esi, eax\nand     ecx, 0Fh\nshl     ebx, cl\nloc_401c1e:\nmov     rax, rdi\ncqo\nidiv    rbx\nmov     rdi, rax\njmp     short loc_401BDC\nloc_401c2b:\ntest    edx, edx\njns     loc_401B09\nloc_401c33:\njmp     short loc_401BF7\nloc_401c35:\nshr     eax, 0Eh\nmov     esi, eax\nand     esi, 3FFh\njz      short loc_401C73\nloc_401c42:\ncmp     r10d, 0Ah\njle     short loc_401C73\nloc_401c48:\nxor     ecx, ecx\nmov     r8d, 0Bh\njmp     short loc_401C60\nloc_401c52:\ntest    ebx, ebx\njz      short loc_401C73\nloc_401c56:\ncmp     ecx, 200h\njz      short loc_401C9A\nloc_401c5e:\nmov     ecx, edi\nloc_401c60:\nlea     edi, [rcx+1]\nmov     eax, r8d\ncpuid\nand     ecx, 0FF0h\nmovzx   ebx, bl\njnz     short loc_401C52\nloc_401c73:\nlea     r11d, [rsi+1]\njmp     loc_401AFF\nloc_401c7c:\nmov     esi, cs:dword_6FF964\nmov     edi, 0BFh\ncall    handle_intel\nmov     r8d, 2\nmov     rbp, rax\njmp     loc_401AB3\nloc_401c9a:\nbsr     ecx, esi\nor      esi, 0FFFFFFFFh\nadd     ecx, 1\nsub     ebx, 1\nshl     esi, cl\nnot     esi\nand     esi, ebx\njmp     short loc_401C73", "push    r12\nmov     eax, cs:__cpu_features\npush    rbp\ntest    eax, eax\npush    rbx\njz      short loc_4021B1\nloc_40219e:\ncmp     eax, 1\njz      short loc_4021BE\nloc_4021a3:\ncmp     eax, 2\njz      loc_4022C1\nloc_4021ac:\npop     rbx\npop     rbp\npop     r12\nretn\nloc_4021b1:\ncall    __init_cpu_features\nmov     eax, cs:__cpu_features\njmp     short loc_40219E\nloc_4021be:\nmov     esi, cs:dword_6FC8E4\nmov     edi, 0BCh\ncall    handle_intel\nmov     esi, cs:dword_6FC8E4\nmov     edi, 0C2h\nmov     r12, rax\ncall    handle_intel\ntest    rax, rax\nmov     rbp, rax\nmov     r8d, 3\njle     loc_4023BC\nloc_4021f3:\nmov     r10d, cs:dword_6FC8E4\nmov     r11d, cs:dword_6FC8EC\ncmp     r10d, 3\njle     short loc_402237\nloc_402207:\nxor     ecx, ecx\nmov     r9d, 4\njmp     short loc_40222B\nloc_402218:\nmov     edx, eax\nshr     edx, 5\nand     edx, 7\ncmp     edx, r8d\njz      loc_402375\nloc_402229:\nmov     ecx, edi\nloc_40222b:\nlea     edi, [rcx+1]\nmov     eax, r9d\ncpuid\ntest    al, 1Fh\njnz     short loc_402218\nloc_402237:\nshr     r11d, 10h\nmovzx   r11d, r11b\nloc_40223f:\ntest    r11d, r11d\njz      short loc_402249\nloc_402244:\ntest    rbp, rbp\njg      short loc_4022B4\nloc_402249:\ntest    r12, r12\njle     short loc_40227A\nloc_40224e:\nmov     rax, r12\nmov     cs:__x86_raw_data_cache_size, r12\nand     r12b, 0\nsar     rax, 1\nmov     cs:__x86_data_cache_size, r12\nmov     cs:__x86_raw_data_cache_size_half, rax\nmov     rax, r12\nsar     rax, 1\nmov     cs:__x86_data_cache_size_half, rax\nloc_40227a:\ntest    rbp, rbp\njle     loc_4021AC\nloc_402283:\nmov     rax, rbp\nmov     cs:__x86_raw_shared_cache_size, rbp\nand     bpl, 0\nsar     rax, 1\nmov     cs:__x86_shared_cache_size, rbp\npop     rbx\nmov     cs:__x86_raw_shared_cache_size_half, rax\nmov     rax, rbp\nsar     rax, 1\npop     rbp\nmov     cs:__x86_shared_cache_size_half, rax\npop     r12\nretn\nloc_4022b4:\nmov     rax, rbp\ncqo\nidiv    r11\nmov     rbp, rax\njmp     short loc_402249\nloc_4022c1:\nmov     edi, 0BCh\ncall    handle_amd\nmov     edi, 0BFh\nmov     r12, rax\ncall    handle_amd\nmov     edi, 0C2h\nmov     rbp, rax\ncall    handle_amd\nmov     esi, 80000000h\nmov     rdi, rax\nmov     eax, esi\ncpuid\ntest    rdi, rdi\nmov     esi, eax\njle     short loc_40231F\nloc_4022f8:\ncmp     eax, 80000007h\nja      short loc_402346\nloc_4022ff:\nmov     esi, 1\nmov     eax, esi\ncpuid\nand     edx, 10000000h\nmov     esi, eax\njz      short loc_40231C\nloc_402312:\nshr     ebx, 10h\nmovzx   ebx, bl\ntest    ebx, ebx\njnz     short loc_40235E\nloc_40231c:\nadd     rbp, rdi\nloc_40231f:\ncmp     esi, 80000000h\njbe     loc_402249\nloc_40232b:\nmov     eax, 80000001h\ncpuid\nand     ch, 1\njz      short loc_40236B\nloc_402337:\nmov     cs:__x86_prefetchw, 0FFFFFFFFh\njmp     loc_402249\nloc_402346:\nmov     esi, 80000008h\nmov     eax, esi\ncpuid\nshr     ecx, 0Ch\nmov     ebx, 1\nmov     esi, eax\nand     ecx, 0Fh\nshl     ebx, cl\nloc_40235e:\nmov     rax, rdi\ncqo\nidiv    rbx\nmov     rdi, rax\njmp     short loc_40231C\nloc_40236b:\ntest    edx, edx\njns     loc_402249\nloc_402373:\njmp     short loc_402337\nloc_402375:\nshr     eax, 0Eh\nmov     esi, eax\nand     esi, 3FFh\njz      short loc_4023B3\nloc_402382:\ncmp     r10d, 0Ah\njle     short loc_4023B3\nloc_402388:\nxor     ecx, ecx\nmov     r8d, 0Bh\njmp     short loc_4023A0\nloc_402392:\ntest    ebx, ebx\njz      short loc_4023B3\nloc_402396:\ncmp     ecx, 200h\njz      short loc_4023DA\nloc_40239e:\nmov     ecx, edi\nloc_4023a0:\nlea     edi, [rcx+1]\nmov     eax, r8d\ncpuid\nand     ecx, 0FF0h\nmovzx   ebx, bl\njnz     short loc_402392\nloc_4023b3:\nlea     r11d, [rsi+1]\njmp     loc_40223F\nloc_4023bc:\nmov     esi, cs:dword_6FC8E4\nmov     edi, 0BFh\ncall    handle_intel\nmov     r8d, 2\nmov     rbp, rax\njmp     loc_4021F3\nloc_4023da:\nbsr     ecx, esi\nor      esi, 0FFFFFFFFh\nadd     ecx, 1\nsub     ebx, 1\nshl     esi, cl\nnot     esi\nand     esi, ebx\njmp     short loc_4023B3"]}, {"ea": "00401ce0", "origin name": "deregister_tm_clones", "ea2": "00402420", "matched name": "deregister_tm_clones", "ratio": "1.000", "bb1": "4", "bb2": "4", "heuristic": "Mnemonics and names", "pseudo": ["signed __int64 deregister_tm_clones()\n{\n  signed __int64 result; // rax\n\n  result = &unk_6FCD57 - &edata;\n  if ( (unsigned __int64)(&unk_6FCD57 - &edata) > 0xE )\n    result = 0LL;\n  return result;\n}", "signed __int64 deregister_tm_clones()\n{\n  signed __int64 result; // rax\n\n  result = &unk_6F9D17 - &edata;\n  if ( (unsigned __int64)(&unk_6F9D17 - &edata) > 0xE )\n    result = 0LL;\n  return result;\n}"], "asm": ["mov     eax, offset unk_6FCD57\npush    rbp\nsub     rax, offset _edata\ncmp     rax, 0Eh\nmov     rbp, rsp\nja      short loc_401CF7\nloc_401cf5:\npop     rbp\nretn\nloc_401cf7:\nmov     eax, 0\ntest    rax, rax\njz      short loc_401CF5\nloc_401d01:\npop     rbp\nmov     edi, offset _edata\njmp     rax", "mov     eax, offset unk_6F9D17\npush    rbp\nsub     rax, offset _edata\ncmp     rax, 0Eh\nmov     rbp, rsp\nja      short loc_402437\nloc_402435:\npop     rbp\nretn\nloc_402437:\nmov     eax, 0\ntest    rax, rax\njz      short loc_402435\nloc_402441:\npop     rbp\nmov     edi, offset _edata\njmp     rax"]}, {"ea": "00401d10", "origin name": "register_tm_clones", "ea2": "00402450", "matched name": "register_tm_clones", "ratio": "1.000", "bb1": "4", "bb2": "4", "heuristic": "Mnemonics and names", "pseudo": ["__int64 register_tm_clones()\n{\n  return 0LL;\n}", "__int64 register_tm_clones()\n{\n  return 0LL;\n}"], "asm": ["mov     eax, offset _edata\npush    rbp\nsub     rax, offset _edata\nsar     rax, 3\nmov     rbp, rsp\nmov     rdx, rax\nshr     rdx, 3Fh\nadd     rax, rdx\nsar     rax, 1\njnz     short loc_401D34\nloc_401d32:\npop     rbp\nretn\nloc_401d34:\nmov     edx, 0\ntest    rdx, rdx\njz      short loc_401D32\nloc_401d3e:\npop     rbp\nmov     rsi, rax\nmov     edi, offset _edata\njmp     rdx", "mov     eax, offset _edata\npush    rbp\nsub     rax, offset _edata\nsar     rax, 3\nmov     rbp, rsp\nmov     rdx, rax\nshr     rdx, 3Fh\nadd     rax, rdx\nsar     rax, 1\njnz     short loc_402474\nloc_402472:\npop     rbp\nretn\nloc_402474:\nmov     edx, 0\ntest    rdx, rdx\njz      short loc_402472\nloc_40247e:\npop     rbp\nmov     rsi, rax\nmov     edi, offset _edata\njmp     rdx"]}, {"ea": "00401d50", "origin name": "__do_global_dtors_aux", "ea2": "00402490", "matched name": "__do_global_dtors_aux", "ratio": "1.000", "bb1": "5", "bb2": "5", "heuristic": "Mnemonics and names", "pseudo": ["__int64 (__fastcall *__fastcall _do_global_dtors_aux(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8))(_QWORD)\n{\n  double v8; // xmm4_8\n  double v9; // xmm5_8\n  __int64 (__fastcall *result)(_QWORD); // rax\n\n  if ( !completed_6470 )\n  {\n    deregister_tm_clones();\n    result = (__int64 (__fastcall *)(_QWORD))_deregister_frame_info;\n    if ( _deregister_frame_info )\n      result = (__int64 (__fastcall *)(_QWORD))_deregister_frame_info(\n                                                 &_EH_FRAME_BEGIN__,\n                                                 a1,\n                                                 a2,\n                                                 a3,\n                                                 a4,\n                                                 v8,\n                                                 v9,\n                                                 a7,\n                                                 a8);\n    completed_6470 = 1;\n  }\n  return result;\n}", "__int64 (__fastcall *_do_global_dtors_aux())(_QWORD)\n{\n  __int64 (__fastcall *result)(_QWORD); // rax\n\n  if ( !completed_6470 )\n  {\n    deregister_tm_clones();\n    result = _deregister_frame_info;\n    if ( _deregister_frame_info )\n      result = (__int64 (__fastcall *)(_QWORD))_deregister_frame_info(&_EH_FRAME_BEGIN__);\n    completed_6470 = 1;\n  }\n  return result;\n}"], "asm": ["cmp     cs:completed_6470, 0\njnz     short locret_401D7B\nloc_401d59:\npush    rbp\nmov     rbp, rsp\ncall    deregister_tm_clones\nmov     eax, offset __deregister_frame_info\ntest    rax, rax\njz      short loc_401D73\nloc_401d6c:\nmov     edi, offset __EH_FRAME_BEGIN__\ncall    rax ; __deregister_frame_info\nloc_401d73:\npop     rbp\nmov     cs:completed_6470, 1\nloc_401d7b:\nrep retn", "cmp     cs:completed_6470, 0\njnz     short locret_4024BB\nloc_402499:\npush    rbp\nmov     rbp, rsp\ncall    deregister_tm_clones\nmov     eax, offset __deregister_frame_info\ntest    rax, rax\njz      short loc_4024B3\nloc_4024ac:\nmov     edi, offset __EH_FRAME_BEGIN__\ncall    rax ; __deregister_frame_info\nloc_4024b3:\npop     rbp\nmov     cs:completed_6470, 1\nloc_4024bb:\nrep retn"]}], "partial matching": [{"ea": "004018df", "origin name": "_i18n_number_rewrite_1", "ea2": "004018e0", "matched name": "_i18n_number_rewrite_1", "ratio": "0.920", "bb1": "18", "bb2": "18", "heuristic": "Same constants", "pseudo": ["_DWORD *__fastcall i18n_number_rewrite_1(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)\n{\n  __int64 v11; // r13\n  bool v12; // bl\n  _DWORD *v13; // r14\n  __int64 v14; // rdx\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  int v17; // eax\n  bool v18; // bl\n  void *v19; // rsp\n  unsigned __int64 v20; // r15\n  unsigned __int64 v21; // rax\n  int *v22; // rax\n  int *v23; // rcx\n  _QWORD *v24; // rsi\n  _DWORD *i; // rdx\n  _DWORD *result; // rax\n  int v27; // er8\n  int v28; // eax\n  int v29; // [rsp+0h] [rbp-40h]\n  int v30; // [rsp+4h] [rbp-3Ch]\n  _DWORD *v31; // [rsp+8h] [rbp-38h]\n\n  v11 = a2 - a1;\n  v12 = 1;\n  v31 = (_DWORD *)a3;\n  v13 = (_DWORD *)wctrans(\"to_outpunct\");\n  v30 = towctrans(0x2Eu, v13);\n  v29 = towctrans(0x2Cu, v13);\n  if ( (unsigned __int64)(a2 - a1) > 0x1000 )\n  {\n    _libc_alloca_cutoff(v11, v13, v14, v15, v16);\n    v12 = v17 != 0;\n  }\n  v18 = v12;\n  if ( v18 )\n  {\n    v19 = alloca(v11 + 15);\n    v20 = ((unsigned __int64)&v31 + 7) & 0xFFFFFFFFFFFFFFF0LL;\n  }\n  else\n  {\n    malloc(v11, v13, v14, v15, v16);\n    v20 = v21;\n    if ( !v21 )\n      return (_DWORD *)a1;\n  }\n  mempcpy(v20, a1, v11);\n  v23 = v22;\n  v24 = (_QWORD *)__readfsqword(0xFFFFFFA8);\n  for ( i = v31 - 1; ; --i )\n  {\n    --v23;\n    result = i + 1;\n    if ( (unsigned __int64)v23 < v20 )\n      break;\n    v27 = *v23;\n    if ( (unsigned int)(*v23 - 48) > 9 )\n    {\n      if ( v13 && (v27 & 0xFFFFFFFD) == 44 )\n      {\n        v28 = v30;\n        if ( v27 != 46 )\n          v28 = v29;\n        *i = v28;\n      }\n      else\n      {\n        *i = v27;\n      }\n    }\n    else\n    {\n      *i = *(_DWORD *)(*v24 + 8LL * (v27 + 3) + 64);\n    }\n  }\n  if ( !v18 )\n  {\n    v31 = i + 1;\n    free(v20);\n    result = v31;\n  }\n  return result;\n}", "signed __int64 __fastcall i18n_number_rewrite_1(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v3; // r13\n  bool v4; // bl\n  __int64 v5; // r14\n  int v6; // eax\n  bool v7; // bl\n  void *v8; // rsp\n  int *v9; // r15\n  int *v10; // rax\n  int *v11; // rax\n  int *v12; // rcx\n  _QWORD *v13; // rsi\n  _DWORD *i; // rdx\n  signed __int64 result; // rax\n  int v16; // er8\n  int v17; // eax\n  int v18; // [rsp-48h] [rbp-48h]\n  int v19; // [rsp-44h] [rbp-44h]\n  __int64 v20; // [rsp-40h] [rbp-40h]\n  __int64 v21; // [rsp-40h] [rbp-40h]\n  signed __int64 v22; // [rsp-40h] [rbp-40h]\n\n  v3 = a2 - a1;\n  v4 = 1;\n  v20 = a3;\n  v5 = wctrans(\"to_outpunct\");\n  v19 = towctrans(46LL, v5);\n  v18 = towctrans(44LL, v5);\n  if ( (unsigned __int64)(a2 - a1) > 0x1000 )\n  {\n    _libc_alloca_cutoff(v3);\n    v4 = v6 != 0;\n  }\n  v7 = v4;\n  if ( v7 )\n  {\n    v8 = alloca(v3 + 15);\n    v9 = (int *)(((unsigned __int64)&v20 + 7) & 0xFFFFFFFFFFFFFFF0LL);\n  }\n  else\n  {\n    malloc(v3);\n    v9 = v10;\n    if ( !v10 )\n      return a1;\n  }\n  mempcpy(v9, a1, v3);\n  v12 = v11;\n  v13 = (_QWORD *)__readfsqword(0xFFFFFFA8);\n  for ( i = (_DWORD *)(v21 - 4); ; --i )\n  {\n    --v12;\n    result = (signed __int64)(i + 1);\n    if ( v12 < v9 )\n      break;\n    v16 = *v12;\n    if ( (unsigned int)(*v12 - 48) > 9 )\n    {\n      if ( v5 && (v16 & 0xFFFFFFFD) == 44 )\n      {\n        v17 = v19;\n        if ( v16 != 46 )\n          v17 = v18;\n        *i = v17;\n      }\n      else\n      {\n        *i = v16;\n      }\n    }\n    else\n    {\n      *i = *(_DWORD *)(*v13 + 8LL * (v16 + 3) + 64);\n    }\n  }\n  if ( !v7 )\n  {\n    v22 = (signed __int64)(i + 1);\n    free(v9);\n    result = v22;\n  }\n  return result;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\npush    r15\npush    r14\npush    r13\nmov     r13, rsi\npush    r12\nmov     r12, rdi\nmov     edi, offset aToOutpunct; \"to_outpunct\"\nsub     r13, r12\npush    rbx\nmov     ebx, 1\nsub     rsp, 18h\nmov     [rbp+var_38], rdx\ncall    wctrans\nmov     edi, 2Eh\nmov     r14, rax\nmov     rsi, rax\ncall    towctrans\nmov     rsi, r14\nmov     edi, 2Ch\nmov     [rbp+var_3C], eax\ncall    towctrans\ncmp     r13, 1000h\nmov     [rbp+var_40], eax\njbe     short loc_401947\nloc_401938:\nmov     rdi, r13\nxor     ebx, ebx\ncall    __libc_alloca_cutoff\ntest    eax, eax\nsetnz   bl\nloc_401947:\nand     bl, 1\njz      short loc_401962\nloc_40194c:\nlea     rdx, [r13+1Eh]\nand     rdx, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rdx\nlea     r15, [rsp+40h+var_38+7]\nand     r15, 0FFFFFFFFFFFFFFF0h\njmp     short loc_401976\nloc_401962:\nmov     rdi, r13\ncall    malloc\ntest    rax, rax\nmov     r15, rax\njz      loc_401A05\nloc_401976:\nmov     rdx, r13\nmov     rsi, r12\nmov     rdi, r15\ncall    mempcpy\nmov     rcx, rax\nmov     rax, 0FFFFFFFFFFFFFFA8h\nmov     rdx, [rbp+var_38]\nmov     rsi, fs:[rax]\nsub     rdx, 4\nloc_40199a:\nsub     rcx, 4\nlea     rax, [rdx+4]\ncmp     rcx, r15\njb      short loc_4019EF\nloc_4019a7:\nmov     r8d, [rcx]\nlea     r9d, [r8-30h]\ncmp     r9d, 9\nja      short loc_4019C7\nloc_4019b4:\nmov     rax, [rsi]\nadd     r8d, 3\nmovsxd  r8, r8d\nmov     eax, [rax+r8*8+40h]\nmov     [rdx], eax\njmp     short loc_4019E9\nloc_4019c7:\ntest    r14, r14\njz      short loc_4019D7\nloc_4019cc:\nmov     eax, r8d\nand     eax, 0FFFFFFFDh\ncmp     eax, 2Ch\njz      short loc_4019DC\nloc_4019d7:\nmov     [rdx], r8d\njmp     short loc_4019E9\nloc_4019dc:\nmov     eax, [rbp+var_3C]\ncmp     r8d, 2Eh\ncmovnz  eax, [rbp+var_40]\nmov     [rdx], eax\nloc_4019e9:\nsub     rdx, 4\njmp     short loc_40199A\nloc_4019ef:\ntest    bl, bl\njnz     short loc_401A08\nloc_4019f3:\nmov     rdi, r15\nmov     [rbp+var_38], rax\ncall    free\nmov     rax, [rbp+var_38]\njmp     short loc_401A08\nloc_401a05:\nmov     rax, r12\nloc_401a08:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn", "push    rbp\nmov     rbp, rsp\npush    r15\npush    r14\npush    r13\nmov     r13, rsi\npush    r12\nmov     r12, rdi\nmov     edi, offset aToOutpunct; \"to_outpunct\"\nsub     r13, r12\npush    rbx\nmov     ebx, 1\nsub     rsp, 18h\nmov     [rbp-38h], rdx\ncall    wctrans\nmov     edi, 2Eh\nmov     r14, rax\nmov     rsi, rax\ncall    towctrans\nmov     rsi, r14\nmov     edi, 2Ch\nmov     [rbp-3Ch], eax\ncall    towctrans\ncmp     r13, 1000h\nmov     [rbp-40h], eax\njbe     short loc_401948\nloc_401939:\nmov     rdi, r13\nxor     ebx, ebx\ncall    __libc_alloca_cutoff\ntest    eax, eax\nsetnz   bl\nloc_401948:\nand     bl, 1\njz      short loc_401963\nloc_40194d:\nlea     rdx, [r13+1Eh]\nand     rdx, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rdx\nlea     r15, [rsp+0Fh]\nand     r15, 0FFFFFFFFFFFFFFF0h\njmp     short loc_401977\nloc_401963:\nmov     rdi, r13\ncall    malloc\ntest    rax, rax\nmov     r15, rax\njz      loc_401A06\nloc_401977:\nmov     rdx, r13\nmov     rsi, r12\nmov     rdi, r15\ncall    mempcpy\nmov     rcx, rax\nmov     rax, 0FFFFFFFFFFFFFFA8h\nmov     rdx, [rbp-38h]\nmov     rsi, fs:[rax]\nsub     rdx, 4\nloc_40199b:\nsub     rcx, 4\nlea     rax, [rdx+4]\ncmp     rcx, r15\njb      short loc_4019F0\nloc_4019a8:\nmov     r8d, [rcx]\nlea     r9d, [r8-30h]\ncmp     r9d, 9\nja      short loc_4019C8\nloc_4019b5:\nmov     rax, [rsi]\nadd     r8d, 3\nmovsxd  r8, r8d\nmov     eax, [rax+r8*8+40h]\nmov     [rdx], eax\njmp     short loc_4019EA\nloc_4019c8:\ntest    r14, r14\njz      short loc_4019D8\nloc_4019cd:\nmov     eax, r8d\nand     eax, 0FFFFFFFDh\ncmp     eax, 2Ch\njz      short loc_4019DD\nloc_4019d8:\nmov     [rdx], r8d\njmp     short loc_4019EA\nloc_4019dd:\nmov     eax, [rbp-3Ch]\ncmp     r8d, 2Eh\ncmovnz  eax, [rbp-40h]\nmov     [rdx], eax\nloc_4019ea:\nsub     rdx, 4\njmp     short loc_40199B\nloc_4019f0:\ntest    bl, bl\njnz     short loc_401A09\nloc_4019f4:\nmov     rdi, r15; void *\nmov     [rbp-38h], rax\ncall    free\nmov     rax, [rbp-38h]\njmp     short loc_401A09\nloc_401a06:\nmov     rax, r12\nloc_401a09:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn"]}, {"ea": "004af900", "origin name": "free_key_mem", "ea2": "00401a20", "matched name": "fini", "ratio": "0.550", "bb1": "6", "bb2": "5", "heuristic": "Same constants", "pseudo": ["__int64 __fastcall free_key_mem(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)\n{\n  const void *v9; // rax\n  __int64 v10; // rbx\n\n  v9 = *(const void **)(a1 + 24);\n  v10 = a1;\n  if ( v9 && memcmp(v9, \"out of memory\", 0xEuLL) )\n    free((__int64)v9, a2, a3, a4, a5, a6, a7, a8, a9);\n  free(v10, a2, a3, a4, a5, a6, a7, a8, a9);\n  return 0LL;\n}", "void fini()\n{\n  if ( qword_6FBFB8 )\n  {\n    if ( memcmp(qword_6FBFB8, \"out of memory\", 0xEuLL) )\n      free(qword_6FBFB8);\n  }\n}"], "asm": ["push    rbx\nmov     rax, [rdi+18h]\nmov     rbx, rdi\ntest    rax, rax\njz      short loc_4AF926\nloc_4af90d:\nmov     edi, offset _dl_out_of_memory; \"out of memory\"\nmov     ecx, 0Eh\nmov     rsi, rax\nrepe cmpsb\njz      short loc_4AF926\nloc_4af91e:\nmov     rdi, rax\ncall    free\nloc_4af926:\nmov     rdi, rbx\ncall    free\nmov     eax, 0\ntest    rax, rax\njz      short loc_4AF943\nloc_4af938:\npop     rbx\nxor     esi, esi\nmov     edi, cs:key\njmp     rax\nloc_4af943:\npop     rbx\nretn", "mov     rax, cs:qword_6FBFB8\ntest    rax, rax\njz      short locret_401A3D\nloc_401a2c:\nmov     edi, offset _dl_out_of_memory; \"out of memory\"\nmov     ecx, 0Eh\nmov     rsi, rax\nrepe cmpsb\njnz     short loc_401A3E\nloc_401a3d:\nretn\nloc_401a3e:\nmov     rdi, rax; void *\njmp     free\nloc_429bd0:\nmov     rax, cs:__free_hook"]}, {"ea": "00405a12", "origin name": "fchmod_or_lchmod", "ea2": "00403a30", "matched name": "fchmod_or_lchmod", "ratio": "0.560", "bb1": "4", "bb2": "5", "heuristic": "Similar pseudo-code and names", "pseudo": ["__int64 __fastcall fchmod_or_lchmod(unsigned int a1, __int64 a2, unsigned int a3)\n{\n  __int64 result; // rax\n\n  if ( (a1 & 0x80000000) != 0 )\n    result = chmod();\n  else\n    result = fchmod();\n  return result;\n}", "int __fastcall fchmod_or_lchmod(int desc, const char *name, mode_t mode)\n{\n  int result; // eax\n\n  if ( desc < 0 )\n    result = chmod(name, mode);\n  else\n    result = fchmod(desc, mode);\n  return result;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\nsub     rsp, 10h\nmov     [rbp+var_4], edi\nmov     [rbp+var_10], rsi\nmov     [rbp+var_8], edx\ncmp     [rbp+var_4], 0\njs      short loc_405A3B\nloc_405a2a:\nmov     edx, [rbp+var_8]\nmov     eax, [rbp+var_4]\nmov     esi, edx\nmov     edi, eax\ncall    fchmod\njmp     short locret_405A4C\nloc_405a3b:\nmov     edx, [rbp+var_8]\nmov     rax, [rbp+var_10]\nmov     esi, edx\nmov     rdi, rax\ncall    chmod\nloc_405a4c:\nleave\nretn", "test    edi, edi\nmov     rax, name\nmov     esi, edx\njs      short loc_403A40\nloc_403a39:\njmp     fchmod\nloc_403a40:\nmov     desc, name\njmp     chmod\nloc_460930:\nmov     eax, 5Ah; Alternative name is '__chmod'\nloc_460950:\nmov     eax, 5Bh; Alternative name is '__fchmod'"]}, {"ea": "0041390f", "origin name": "chmod_or_fchmod", "ea2": "00403a30", "matched name": "fchmod_or_lchmod", "ratio": "0.560", "bb1": "4", "bb2": "5", "heuristic": "Similar pseudo-code and names", "pseudo": ["__int64 __fastcall chmod_or_fchmod(__int64 a1, unsigned int a2, unsigned int a3)\n{\n  __int64 result; // rax\n\n  if ( a2 == -1 )\n    result = chmod();\n  else\n    result = fchmod();\n  return result;\n}", "int __fastcall fchmod_or_lchmod(int desc, const char *name, mode_t mode)\n{\n  int result; // eax\n\n  if ( desc < 0 )\n    result = chmod(name, mode);\n  else\n    result = fchmod(desc, mode);\n  return result;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\nsub     rsp, 10h\nmov     [rbp+var_8], rdi\nmov     [rbp+var_C], esi\nmov     [rbp+var_10], edx\ncmp     [rbp+var_C], 0FFFFFFFFh\njz      short loc_413938\nloc_413927:\nmov     edx, [rbp+var_10]\nmov     eax, [rbp+var_C]\nmov     esi, edx\nmov     edi, eax\ncall    fchmod\njmp     short locret_413949\nloc_413938:\nmov     edx, [rbp+var_10]\nmov     rax, [rbp+var_8]\nmov     esi, edx\nmov     rdi, rax\ncall    chmod\nloc_413949:\nleave\nretn", "test    edi, edi\nmov     rax, name\nmov     esi, edx\njs      short loc_403A40\nloc_403a39:\njmp     fchmod\nloc_403a40:\nmov     desc, name\njmp     chmod\nloc_460930:\nmov     eax, 5Ah; Alternative name is '__chmod'\nloc_460950:\nmov     eax, 5Bh; Alternative name is '__fchmod'"]}], "unreliable matching": [{"ea": "004013be", "origin name": "_i18n_number_rewrite", "ea2": "004018e0", "matched name": "_i18n_number_rewrite_1", "ratio": "0.480", "bb1": "28", "bb2": "18", "heuristic": "Same constants", "pseudo": ["__int64 __fastcall i18n_number_rewrite(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)\n{\n  __int64 v11; // r14\n  __int64 v12; // rbx\n  _DWORD *v13; // r13\n  unsigned __int64 v14; // rsi\n  int v15; // er12\n  int v16; // eax\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  int v19; // er11\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  signed __int64 v22; // rax\n  int v23; // er11\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  signed __int64 v26; // rax\n  unsigned __int64 v27; // rdx\n  bool v28; // bl\n  int v29; // eax\n  bool v30; // bl\n  void *v31; // rsp\n  unsigned __int64 v32; // r12\n  unsigned __int64 v33; // rax\n  __int64 v34; // rdx\n  _BYTE *v35; // rax\n  _BYTE *v36; // r10\n  int v37; // ecx\n  const char *v38; // r11\n  unsigned __int64 v39; // r8\n  bool v40; // zf\n  __int16 *v41; // r8\n  signed __int64 v42; // rcx\n  __int16 *v43; // rdi\n  signed __int64 v44; // rcx\n  __int64 result; // rax\n  __int64 v46; // [rsp+8h] [rbp-88h]\n  __int64 v47; // [rsp+10h] [rbp-80h]\n  __int16 v48; // [rsp+20h] [rbp-70h]\n  __int16 v49; // [rsp+40h] [rbp-50h]\n\n  v11 = a3;\n  v12 = a2;\n  v13 = (_DWORD *)wctrans(\"to_outpunct\");\n  v14 = (unsigned __int64)v13;\n  v15 = towctrans(0x2Eu, v13);\n  v16 = towctrans(0x2Cu, v13);\n  if ( v13 )\n  {\n    LODWORD(v46) = v16;\n    v47 = 0LL;\n    v22 = wcrtomb(&v47, (char *)&v48, v15, v19, a4, a5, a6, a7, v20, v21, a10, a11);\n    if ( v22 == -1 )\n      v48 = 46;\n    else\n      *((_BYTE *)&v48 + v22) = 0;\n    v14 = (unsigned int)v46;\n    v47 = 0LL;\n    v26 = wcrtomb(&v47, (char *)&v49, v46, v23, a4, a5, a6, a7, v24, v25, a10, a11);\n    if ( v26 == -1 )\n      v49 = 44;\n    else\n      *((_BYTE *)&v49 + v26) = 0;\n  }\n  v27 = v12 - a1;\n  v28 = 1;\n  if ( v27 > 0x1000 )\n  {\n    v46 = v27;\n    _libc_alloca_cutoff(v27, v14, v27, v17, v18);\n    v27 = v46;\n    v28 = v29 != 0;\n  }\n  v30 = v28;\n  if ( v30 )\n  {\n    v31 = alloca(v27 + 15);\n    v32 = ((unsigned __int64)&v46 + 7) & 0xFFFFFFFFFFFFFFF0LL;\n  }\n  else\n  {\n    v46 = v27;\n    malloc(v27, v14, v27, v17, v18);\n    v32 = v33;\n    v27 = v46;\n    if ( !v33 )\n      return a1;\n  }\n  mempcpy(v32, a1, v27);\n  v34 = v11;\n  v36 = v35;\n  while ( (unsigned __int64)--v36 >= v32 )\n  {\n    v37 = (char)*v36;\n    if ( (unsigned __int8)(*v36 - 48) > 9u )\n    {\n      if ( v13 && (v37 & 0xFD) == 44 )\n      {\n        v40 = (_BYTE)v37 == 46;\n        v41 = &v48;\n        v42 = -1LL;\n        if ( !v40 )\n          v41 = &v49;\n        v43 = v41;\n        do\n        {\n          if ( !v42 )\n            break;\n          v40 = *(_BYTE *)v43 == 0;\n          v43 = (__int16 *)((char *)v43 + 1);\n          --v42;\n        }\n        while ( !v40 );\n        v44 = ~v42 - 1;\n        for ( v34 -= v44; --v44 != -1; *(_BYTE *)(v34 + v44) = *((_BYTE *)v41 + v44) )\n          ;\n      }\n      else\n      {\n        *(_BYTE *)(v34-- - 1) = v37;\n      }\n    }\n    else\n    {\n      v38 = *(const char **)(*(_QWORD *)__readfsqword(0xFFFFFFA8) + 8LL * (v37 - 7) + 64);\n      v39 = strlen(v38);\n      for ( v34 -= v39; --v39 != -1LL; *(_BYTE *)(v34 + v39) = v38[v39] )\n        ;\n    }\n  }\n  result = v34;\n  if ( !v30 )\n  {\n    v46 = v34;\n    free(v32);\n    result = v46;\n  }\n  return result;\n}", "signed __int64 __fastcall i18n_number_rewrite_1(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v3; // r13\n  bool v4; // bl\n  __int64 v5; // r14\n  int v6; // eax\n  bool v7; // bl\n  void *v8; // rsp\n  int *v9; // r15\n  int *v10; // rax\n  int *v11; // rax\n  int *v12; // rcx\n  _QWORD *v13; // rsi\n  _DWORD *i; // rdx\n  signed __int64 result; // rax\n  int v16; // er8\n  int v17; // eax\n  int v18; // [rsp-48h] [rbp-48h]\n  int v19; // [rsp-44h] [rbp-44h]\n  __int64 v20; // [rsp-40h] [rbp-40h]\n  __int64 v21; // [rsp-40h] [rbp-40h]\n  signed __int64 v22; // [rsp-40h] [rbp-40h]\n\n  v3 = a2 - a1;\n  v4 = 1;\n  v20 = a3;\n  v5 = wctrans(\"to_outpunct\");\n  v19 = towctrans(46LL, v5);\n  v18 = towctrans(44LL, v5);\n  if ( (unsigned __int64)(a2 - a1) > 0x1000 )\n  {\n    _libc_alloca_cutoff(v3);\n    v4 = v6 != 0;\n  }\n  v7 = v4;\n  if ( v7 )\n  {\n    v8 = alloca(v3 + 15);\n    v9 = (int *)(((unsigned __int64)&v20 + 7) & 0xFFFFFFFFFFFFFFF0LL);\n  }\n  else\n  {\n    malloc(v3);\n    v9 = v10;\n    if ( !v10 )\n      return a1;\n  }\n  mempcpy(v9, a1, v3);\n  v12 = v11;\n  v13 = (_QWORD *)__readfsqword(0xFFFFFFA8);\n  for ( i = (_DWORD *)(v21 - 4); ; --i )\n  {\n    --v12;\n    result = (signed __int64)(i + 1);\n    if ( v12 < v9 )\n      break;\n    v16 = *v12;\n    if ( (unsigned int)(*v12 - 48) > 9 )\n    {\n      if ( v5 && (v16 & 0xFFFFFFFD) == 44 )\n      {\n        v17 = v19;\n        if ( v16 != 46 )\n          v17 = v18;\n        *i = v17;\n      }\n      else\n      {\n        *i = v16;\n      }\n    }\n    else\n    {\n      *i = *(_DWORD *)(*v13 + 8LL * (v16 + 3) + 64);\n    }\n  }\n  if ( !v7 )\n  {\n    v22 = (signed __int64)(i + 1);\n    free(v9);\n    result = v22;\n  }\n  return result;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\npush    r15\nmov     r15, rdi\nmov     edi, offset aToOutpunct; \"to_outpunct\"\npush    r14\nmov     r14, rdx\npush    r13\npush    r12\npush    rbx\nmov     rbx, rsi\nsub     rsp, 68h\ncall    wctrans\nmov     edi, 2Eh\nmov     r13, rax\nmov     rsi, rax\ncall    towctrans\nmov     rsi, r13\nmov     edi, 2Ch\nmov     r12d, eax\ncall    towctrans\ntest    r13, r13\njz      short loc_401468\nloc_401407:\nlea     rdx, [rbp+var_80]\nlea     rdi, [rbp+var_70]\nmov     esi, r12d\nmov     dword ptr [rbp+var_88], eax\nmov     [rbp+var_80], 0\ncall    wcrtomb\ncmp     rax, 0FFFFFFFFFFFFFFFFh\nmov     ecx, dword ptr [rbp+var_88]\njnz     short loc_401439\nloc_401431:\nmov     [rbp+var_70], 2Eh\njmp     short loc_40143E\nloc_401439:\nmov     byte ptr [rbp+rax+var_70], 0\nloc_40143e:\nlea     rdx, [rbp+var_80]\nlea     rdi, [rbp+var_50]\nmov     esi, ecx\nmov     [rbp+var_80], 0\ncall    wcrtomb\ncmp     rax, 0FFFFFFFFFFFFFFFFh\njnz     short loc_401463\nloc_40145b:\nmov     [rbp+var_50], 2Ch\njmp     short loc_401468\nloc_401463:\nmov     byte ptr [rbp+rax+var_50], 0\nloc_401468:\nsub     rbx, r15\nmov     rdx, rbx\nmov     ebx, 1\ncmp     rdx, 1000h\njbe     short loc_401499\nloc_40147c:\nmov     rdi, rdx\nmov     [rbp+var_88], rdx\nxor     ebx, ebx\ncall    __libc_alloca_cutoff\nmov     rdx, [rbp+var_88]\ntest    eax, eax\nsetnz   bl\nloc_401499:\nand     bl, 1\njz      short loc_4014B4\nloc_40149e:\nlea     rax, [rdx+1Eh]\nand     rax, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rax\nlea     r12, [rsp+90h+var_88+7]\nand     r12, 0FFFFFFFFFFFFFFF0h\njmp     short loc_4014D6\nloc_4014b4:\nmov     rdi, rdx\nmov     [rbp+var_88], rdx\ncall    malloc\ntest    rax, rax\nmov     r12, rax\nmov     rdx, [rbp+var_88]\njz      loc_4015B6\nloc_4014d6:\nmov     rsi, r15\nmov     rdi, r12\nlea     r15, [rbp+var_50]\ncall    mempcpy\nmov     rdx, r14\nlea     r14, [rbp+var_70]\nmov     r10, rax\nor      rsi, 0FFFFFFFFFFFFFFFFh\nxor     eax, eax\nloc_4014f5:\ndec     r10\ncmp     r10, r12\njb      loc_401597\nloc_401501:\nmovsx   ecx, byte ptr [r10]\nlea     edi, [rcx-30h]\ncmp     dil, 9\nja      short loc_40154C\nloc_40150e:\nmov     rdi, 0FFFFFFFFFFFFFFA8h\nsub     ecx, 7\nmovsxd  rcx, ecx\nmov     rdi, fs:[rdi]\nmov     rdi, [rdi]\nmov     r11, [rdi+rcx*8+40h]\nmov     rcx, rsi\nmov     rdi, r11\nrepne scasb\nnot     rcx\nlea     r8, [rcx-1]\nsub     rdx, r8\nloc_401539:\ndec     r8\ncmp     r8, 0FFFFFFFFFFFFFFFFh\njz      short loc_4014F5\nloc_401542:\nmov     r9b, [r11+r8]\nmov     [rdx+r8], r9b\njmp     short loc_401539\nloc_40154c:\ntest    r13, r13\njz      short loc_40155D\nloc_401551:\nmov     dil, cl\nand     edi, 0FFFFFFFDh\ncmp     dil, 2Ch\njz      short loc_401565\nloc_40155d:\nmov     [rdx-1], cl\ndec     rdx\njmp     short loc_4014F5\nloc_401565:\ncmp     cl, 2Eh\nmov     r8, r14\nmov     rcx, rsi\ncmovnz  r8, r15\nmov     rdi, r8\nrepne scasb\nnot     rcx\ndec     rcx\nsub     rdx, rcx\nloc_401580:\ndec     rcx\ncmp     rcx, 0FFFFFFFFFFFFFFFFh\njz      loc_4014F5\nloc_40158d:\nmov     dil, [r8+rcx]\nmov     [rdx+rcx], dil\njmp     short loc_401580\nloc_401597:\ntest    bl, bl\nmov     rax, rdx\njnz     short loc_4015B9\nloc_40159e:\nmov     rdi, r12\nmov     [rbp+var_88], rdx\ncall    free\nmov     rax, [rbp+var_88]\njmp     short loc_4015B9\nloc_4015b6:\nmov     rax, r15\nloc_4015b9:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn", "push    rbp\nmov     rbp, rsp\npush    r15\npush    r14\npush    r13\nmov     r13, rsi\npush    r12\nmov     r12, rdi\nmov     edi, offset aToOutpunct; \"to_outpunct\"\nsub     r13, r12\npush    rbx\nmov     ebx, 1\nsub     rsp, 18h\nmov     [rbp-38h], rdx\ncall    wctrans\nmov     edi, 2Eh\nmov     r14, rax\nmov     rsi, rax\ncall    towctrans\nmov     rsi, r14\nmov     edi, 2Ch\nmov     [rbp-3Ch], eax\ncall    towctrans\ncmp     r13, 1000h\nmov     [rbp-40h], eax\njbe     short loc_401948\nloc_401939:\nmov     rdi, r13\nxor     ebx, ebx\ncall    __libc_alloca_cutoff\ntest    eax, eax\nsetnz   bl\nloc_401948:\nand     bl, 1\njz      short loc_401963\nloc_40194d:\nlea     rdx, [r13+1Eh]\nand     rdx, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rdx\nlea     r15, [rsp+0Fh]\nand     r15, 0FFFFFFFFFFFFFFF0h\njmp     short loc_401977\nloc_401963:\nmov     rdi, r13\ncall    malloc\ntest    rax, rax\nmov     r15, rax\njz      loc_401A06\nloc_401977:\nmov     rdx, r13\nmov     rsi, r12\nmov     rdi, r15\ncall    mempcpy\nmov     rcx, rax\nmov     rax, 0FFFFFFFFFFFFFFA8h\nmov     rdx, [rbp-38h]\nmov     rsi, fs:[rax]\nsub     rdx, 4\nloc_40199b:\nsub     rcx, 4\nlea     rax, [rdx+4]\ncmp     rcx, r15\njb      short loc_4019F0\nloc_4019a8:\nmov     r8d, [rcx]\nlea     r9d, [r8-30h]\ncmp     r9d, 9\nja      short loc_4019C8\nloc_4019b5:\nmov     rax, [rsi]\nadd     r8d, 3\nmovsxd  r8, r8d\nmov     eax, [rax+r8*8+40h]\nmov     [rdx], eax\njmp     short loc_4019EA\nloc_4019c8:\ntest    r14, r14\njz      short loc_4019D8\nloc_4019cd:\nmov     eax, r8d\nand     eax, 0FFFFFFFDh\ncmp     eax, 2Ch\njz      short loc_4019DD\nloc_4019d8:\nmov     [rdx], r8d\njmp     short loc_4019EA\nloc_4019dd:\nmov     eax, [rbp-3Ch]\ncmp     r8d, 2Eh\ncmovnz  eax, [rbp-40h]\nmov     [rdx], eax\nloc_4019ea:\nsub     rdx, 4\njmp     short loc_40199B\nloc_4019f0:\ntest    bl, bl\njnz     short loc_401A09\nloc_4019f4:\nmov     rdi, r15; void *\nmov     [rbp-38h], rax\ncall    free\nmov     rax, [rbp-38h]\njmp     short loc_401A09\nloc_401a06:\nmov     rax, r12\nloc_401a09:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn"]}, {"ea": "004015c8", "origin name": "_i18n_number_rewrite_0", "ea2": "004018e0", "matched name": "_i18n_number_rewrite_1", "ratio": "0.480", "bb1": "28", "bb2": "18", "heuristic": "Same constants", "pseudo": ["__int64 __fastcall i18n_number_rewrite_0(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)\n{\n  __int64 v11; // r14\n  __int64 v12; // rbx\n  _DWORD *v13; // r13\n  unsigned __int64 v14; // rsi\n  int v15; // er12\n  int v16; // eax\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  int v19; // er11\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  signed __int64 v22; // rax\n  int v23; // er11\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  signed __int64 v26; // rax\n  unsigned __int64 v27; // rdx\n  bool v28; // bl\n  int v29; // eax\n  bool v30; // bl\n  void *v31; // rsp\n  unsigned __int64 v32; // r12\n  unsigned __int64 v33; // rax\n  __int64 v34; // rdx\n  _BYTE *v35; // rax\n  _BYTE *v36; // r10\n  int v37; // ecx\n  const char *v38; // r11\n  unsigned __int64 v39; // r8\n  bool v40; // zf\n  __int16 *v41; // r8\n  signed __int64 v42; // rcx\n  __int16 *v43; // rdi\n  signed __int64 v44; // rcx\n  __int64 result; // rax\n  __int64 v46; // [rsp+8h] [rbp-88h]\n  __int64 v47; // [rsp+10h] [rbp-80h]\n  __int16 v48; // [rsp+20h] [rbp-70h]\n  __int16 v49; // [rsp+40h] [rbp-50h]\n\n  v11 = a3;\n  v12 = a2;\n  v13 = (_DWORD *)wctrans(\"to_outpunct\");\n  v14 = (unsigned __int64)v13;\n  v15 = towctrans(0x2Eu, v13);\n  v16 = towctrans(0x2Cu, v13);\n  if ( v13 )\n  {\n    LODWORD(v46) = v16;\n    v47 = 0LL;\n    v22 = wcrtomb(&v47, (char *)&v48, v15, v19, a4, a5, a6, a7, v20, v21, a10, a11);\n    if ( v22 == -1 )\n      v48 = 46;\n    else\n      *((_BYTE *)&v48 + v22) = 0;\n    v14 = (unsigned int)v46;\n    v47 = 0LL;\n    v26 = wcrtomb(&v47, (char *)&v49, v46, v23, a4, a5, a6, a7, v24, v25, a10, a11);\n    if ( v26 == -1 )\n      v49 = 44;\n    else\n      *((_BYTE *)&v49 + v26) = 0;\n  }\n  v27 = v12 - a1;\n  v28 = 1;\n  if ( v27 > 0x1000 )\n  {\n    v46 = v27;\n    _libc_alloca_cutoff(v27, v14, v27, v17, v18);\n    v27 = v46;\n    v28 = v29 != 0;\n  }\n  v30 = v28;\n  if ( v30 )\n  {\n    v31 = alloca(v27 + 15);\n    v32 = ((unsigned __int64)&v46 + 7) & 0xFFFFFFFFFFFFFFF0LL;\n  }\n  else\n  {\n    v46 = v27;\n    malloc(v27, v14, v27, v17, v18);\n    v32 = v33;\n    v27 = v46;\n    if ( !v33 )\n      return a1;\n  }\n  mempcpy(v32, a1, v27);\n  v34 = v11;\n  v36 = v35;\n  while ( (unsigned __int64)--v36 >= v32 )\n  {\n    v37 = (char)*v36;\n    if ( (unsigned __int8)(*v36 - 48) > 9u )\n    {\n      if ( v13 && (v37 & 0xFD) == 44 )\n      {\n        v40 = (_BYTE)v37 == 46;\n        v41 = &v48;\n        v42 = -1LL;\n        if ( !v40 )\n          v41 = &v49;\n        v43 = v41;\n        do\n        {\n          if ( !v42 )\n            break;\n          v40 = *(_BYTE *)v43 == 0;\n          v43 = (__int16 *)((char *)v43 + 1);\n          --v42;\n        }\n        while ( !v40 );\n        v44 = ~v42 - 1;\n        for ( v34 -= v44; --v44 != -1; *(_BYTE *)(v34 + v44) = *((_BYTE *)v41 + v44) )\n          ;\n      }\n      else\n      {\n        *(_BYTE *)(v34-- - 1) = v37;\n      }\n    }\n    else\n    {\n      v38 = *(const char **)(*(_QWORD *)__readfsqword(0xFFFFFFA8) + 8LL * (v37 - 7) + 64);\n      v39 = strlen(v38);\n      for ( v34 -= v39; --v39 != -1LL; *(_BYTE *)(v34 + v39) = v38[v39] )\n        ;\n    }\n  }\n  result = v34;\n  if ( !v30 )\n  {\n    v46 = v34;\n    free(v32);\n    result = v46;\n  }\n  return result;\n}", "signed __int64 __fastcall i18n_number_rewrite_1(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v3; // r13\n  bool v4; // bl\n  __int64 v5; // r14\n  int v6; // eax\n  bool v7; // bl\n  void *v8; // rsp\n  int *v9; // r15\n  int *v10; // rax\n  int *v11; // rax\n  int *v12; // rcx\n  _QWORD *v13; // rsi\n  _DWORD *i; // rdx\n  signed __int64 result; // rax\n  int v16; // er8\n  int v17; // eax\n  int v18; // [rsp-48h] [rbp-48h]\n  int v19; // [rsp-44h] [rbp-44h]\n  __int64 v20; // [rsp-40h] [rbp-40h]\n  __int64 v21; // [rsp-40h] [rbp-40h]\n  signed __int64 v22; // [rsp-40h] [rbp-40h]\n\n  v3 = a2 - a1;\n  v4 = 1;\n  v20 = a3;\n  v5 = wctrans(\"to_outpunct\");\n  v19 = towctrans(46LL, v5);\n  v18 = towctrans(44LL, v5);\n  if ( (unsigned __int64)(a2 - a1) > 0x1000 )\n  {\n    _libc_alloca_cutoff(v3);\n    v4 = v6 != 0;\n  }\n  v7 = v4;\n  if ( v7 )\n  {\n    v8 = alloca(v3 + 15);\n    v9 = (int *)(((unsigned __int64)&v20 + 7) & 0xFFFFFFFFFFFFFFF0LL);\n  }\n  else\n  {\n    malloc(v3);\n    v9 = v10;\n    if ( !v10 )\n      return a1;\n  }\n  mempcpy(v9, a1, v3);\n  v12 = v11;\n  v13 = (_QWORD *)__readfsqword(0xFFFFFFA8);\n  for ( i = (_DWORD *)(v21 - 4); ; --i )\n  {\n    --v12;\n    result = (signed __int64)(i + 1);\n    if ( v12 < v9 )\n      break;\n    v16 = *v12;\n    if ( (unsigned int)(*v12 - 48) > 9 )\n    {\n      if ( v5 && (v16 & 0xFFFFFFFD) == 44 )\n      {\n        v17 = v19;\n        if ( v16 != 46 )\n          v17 = v18;\n        *i = v17;\n      }\n      else\n      {\n        *i = v16;\n      }\n    }\n    else\n    {\n      *i = *(_DWORD *)(*v13 + 8LL * (v16 + 3) + 64);\n    }\n  }\n  if ( !v7 )\n  {\n    v22 = (signed __int64)(i + 1);\n    free(v9);\n    result = v22;\n  }\n  return result;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\npush    r15\nmov     r15, rdi\nmov     edi, offset aToOutpunct; \"to_outpunct\"\npush    r14\nmov     r14, rdx\npush    r13\npush    r12\npush    rbx\nmov     rbx, rsi\nsub     rsp, 68h\ncall    wctrans\nmov     edi, 2Eh\nmov     r13, rax\nmov     rsi, rax\ncall    towctrans\nmov     rsi, r13\nmov     edi, 2Ch\nmov     r12d, eax\ncall    towctrans\ntest    r13, r13\njz      short loc_401672\nloc_401611:\nlea     rdx, [rbp+var_80]\nlea     rdi, [rbp+var_70]\nmov     esi, r12d\nmov     dword ptr [rbp+var_88], eax\nmov     [rbp+var_80], 0\ncall    wcrtomb\ncmp     rax, 0FFFFFFFFFFFFFFFFh\nmov     ecx, dword ptr [rbp+var_88]\njnz     short loc_401643\nloc_40163b:\nmov     [rbp+var_70], 2Eh\njmp     short loc_401648\nloc_401643:\nmov     byte ptr [rbp+rax+var_70], 0\nloc_401648:\nlea     rdx, [rbp+var_80]\nlea     rdi, [rbp+var_50]\nmov     esi, ecx\nmov     [rbp+var_80], 0\ncall    wcrtomb\ncmp     rax, 0FFFFFFFFFFFFFFFFh\njnz     short loc_40166D\nloc_401665:\nmov     [rbp+var_50], 2Ch\njmp     short loc_401672\nloc_40166d:\nmov     byte ptr [rbp+rax+var_50], 0\nloc_401672:\nsub     rbx, r15\nmov     rdx, rbx\nmov     ebx, 1\ncmp     rdx, 1000h\njbe     short loc_4016A3\nloc_401686:\nmov     rdi, rdx\nmov     [rbp+var_88], rdx\nxor     ebx, ebx\ncall    __libc_alloca_cutoff\nmov     rdx, [rbp+var_88]\ntest    eax, eax\nsetnz   bl\nloc_4016a3:\nand     bl, 1\njz      short loc_4016BE\nloc_4016a8:\nlea     rax, [rdx+1Eh]\nand     rax, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rax\nlea     r12, [rsp+90h+var_88+7]\nand     r12, 0FFFFFFFFFFFFFFF0h\njmp     short loc_4016E0\nloc_4016be:\nmov     rdi, rdx\nmov     [rbp+var_88], rdx\ncall    malloc\ntest    rax, rax\nmov     r12, rax\nmov     rdx, [rbp+var_88]\njz      loc_4017C0\nloc_4016e0:\nmov     rsi, r15\nmov     rdi, r12\nlea     r15, [rbp+var_50]\ncall    mempcpy\nmov     rdx, r14\nlea     r14, [rbp+var_70]\nmov     r10, rax\nor      rsi, 0FFFFFFFFFFFFFFFFh\nxor     eax, eax\nloc_4016ff:\ndec     r10\ncmp     r10, r12\njb      loc_4017A1\nloc_40170b:\nmovsx   ecx, byte ptr [r10]\nlea     edi, [rcx-30h]\ncmp     dil, 9\nja      short loc_401756\nloc_401718:\nmov     rdi, 0FFFFFFFFFFFFFFA8h\nsub     ecx, 7\nmovsxd  rcx, ecx\nmov     rdi, fs:[rdi]\nmov     rdi, [rdi]\nmov     r11, [rdi+rcx*8+40h]\nmov     rcx, rsi\nmov     rdi, r11\nrepne scasb\nnot     rcx\nlea     r8, [rcx-1]\nsub     rdx, r8\nloc_401743:\ndec     r8\ncmp     r8, 0FFFFFFFFFFFFFFFFh\njz      short loc_4016FF\nloc_40174c:\nmov     r9b, [r11+r8]\nmov     [rdx+r8], r9b\njmp     short loc_401743\nloc_401756:\ntest    r13, r13\njz      short loc_401767\nloc_40175b:\nmov     dil, cl\nand     edi, 0FFFFFFFDh\ncmp     dil, 2Ch\njz      short loc_40176F\nloc_401767:\nmov     [rdx-1], cl\ndec     rdx\njmp     short loc_4016FF\nloc_40176f:\ncmp     cl, 2Eh\nmov     r8, r14\nmov     rcx, rsi\ncmovnz  r8, r15\nmov     rdi, r8\nrepne scasb\nnot     rcx\ndec     rcx\nsub     rdx, rcx\nloc_40178a:\ndec     rcx\ncmp     rcx, 0FFFFFFFFFFFFFFFFh\njz      loc_4016FF\nloc_401797:\nmov     dil, [r8+rcx]\nmov     [rdx+rcx], dil\njmp     short loc_40178A\nloc_4017a1:\ntest    bl, bl\nmov     rax, rdx\njnz     short loc_4017C3\nloc_4017a8:\nmov     rdi, r12\nmov     [rbp+var_88], rdx\ncall    free\nmov     rax, [rbp+var_88]\njmp     short loc_4017C3\nloc_4017c0:\nmov     rax, r15\nloc_4017c3:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn", "push    rbp\nmov     rbp, rsp\npush    r15\npush    r14\npush    r13\nmov     r13, rsi\npush    r12\nmov     r12, rdi\nmov     edi, offset aToOutpunct; \"to_outpunct\"\nsub     r13, r12\npush    rbx\nmov     ebx, 1\nsub     rsp, 18h\nmov     [rbp-38h], rdx\ncall    wctrans\nmov     edi, 2Eh\nmov     r14, rax\nmov     rsi, rax\ncall    towctrans\nmov     rsi, r14\nmov     edi, 2Ch\nmov     [rbp-3Ch], eax\ncall    towctrans\ncmp     r13, 1000h\nmov     [rbp-40h], eax\njbe     short loc_401948\nloc_401939:\nmov     rdi, r13\nxor     ebx, ebx\ncall    __libc_alloca_cutoff\ntest    eax, eax\nsetnz   bl\nloc_401948:\nand     bl, 1\njz      short loc_401963\nloc_40194d:\nlea     rdx, [r13+1Eh]\nand     rdx, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rdx\nlea     r15, [rsp+0Fh]\nand     r15, 0FFFFFFFFFFFFFFF0h\njmp     short loc_401977\nloc_401963:\nmov     rdi, r13\ncall    malloc\ntest    rax, rax\nmov     r15, rax\njz      loc_401A06\nloc_401977:\nmov     rdx, r13\nmov     rsi, r12\nmov     rdi, r15\ncall    mempcpy\nmov     rcx, rax\nmov     rax, 0FFFFFFFFFFFFFFA8h\nmov     rdx, [rbp-38h]\nmov     rsi, fs:[rax]\nsub     rdx, 4\nloc_40199b:\nsub     rcx, 4\nlea     rax, [rdx+4]\ncmp     rcx, r15\njb      short loc_4019F0\nloc_4019a8:\nmov     r8d, [rcx]\nlea     r9d, [r8-30h]\ncmp     r9d, 9\nja      short loc_4019C8\nloc_4019b5:\nmov     rax, [rsi]\nadd     r8d, 3\nmovsxd  r8, r8d\nmov     eax, [rax+r8*8+40h]\nmov     [rdx], eax\njmp     short loc_4019EA\nloc_4019c8:\ntest    r14, r14\njz      short loc_4019D8\nloc_4019cd:\nmov     eax, r8d\nand     eax, 0FFFFFFFDh\ncmp     eax, 2Ch\njz      short loc_4019DD\nloc_4019d8:\nmov     [rdx], r8d\njmp     short loc_4019EA\nloc_4019dd:\nmov     eax, [rbp-3Ch]\ncmp     r8d, 2Eh\ncmovnz  eax, [rbp-40h]\nmov     [rdx], eax\nloc_4019ea:\nsub     rdx, 4\njmp     short loc_40199B\nloc_4019f0:\ntest    bl, bl\njnz     short loc_401A09\nloc_4019f4:\nmov     rdi, r15; void *\nmov     [rbp-38h], rax\ncall    free\nmov     rax, [rbp-38h]\njmp     short loc_401A09\nloc_401a06:\nmov     rax, r12\nloc_401a09:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn"]}, {"ea": "00402d53", "origin name": "target_directory_operand", "ea2": "00402650", "matched name": "target_directory_operand", "ratio": "0.410", "bb1": "12", "bb2": "10", "heuristic": "Same constants", "pseudo": ["_BOOL8 __fastcall target_directory_operand(__int64 a1, __int64 a2, _BYTE *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)\n{\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  unsigned int v13; // eax\n  bool v14; // al\n  unsigned int *v15; // rbx\n  const __m128i *v16; // rax\n  _BYTE *v18; // [rsp+8h] [rbp-38h]\n  bool v19; // [rsp+2Bh] [rbp-15h]\n  unsigned int v20; // [rsp+2Ch] [rbp-14h]\n\n  v18 = a3;\n  if ( (unsigned int)stat(a1, a2) )\n    v13 = *(_DWORD *)_errno_location();\n  else\n    v13 = 0;\n  v20 = v13;\n  v14 = !v13 && (*(_DWORD *)(a2 + 24) & 0xF000) == 0x4000;\n  v19 = v14;\n  if ( v20 )\n  {\n    if ( v20 != 2 )\n    {\n      v15 = quotearg_style(4, a1, a4, a5, a6, a7, v11, v12, a10, a11);\n      v16 = (const __m128i *)gettext((__int64)\"failed to access %s\");\n      error(1u, v20, v16, v15);\n    }\n    *v18 = 1;\n  }\n  return v19;\n}", "_Bool __fastcall target_directory_operand(const char *file, stat *st, _Bool *new_dst, _Bool forcing)\n{\n  _Bool *v4; // r14\n  _Bool v5; // r13\n  unsigned int v6; // er12\n  _Bool result; // al\n  char *v8; // rbx\n  __int64 v9; // rax\n  const char *v10; // rdx\n  dir_attr **v11; // rcx\n  _Bool *v12; // r8\n  const cp_options *v13; // r9\n\n  v4 = new_dst;\n  v5 = forcing;\n  if ( !(unsigned int)xstat(1LL, file, st) )\n    return (st->st_mode & 0xF000) == 0x4000;\n  v6 = *(_DWORD *)_errno_location(1LL);\n  if ( !v6 )\n    return (st->st_mode & 0xF000) == 0x4000;\n  if ( v6 == 2 )\n  {\n    *v4 = 1;\n    result = 0;\n  }\n  else if ( v5 )\n  {\n    st->st_mode = 0;\n    result = 0;\n  }\n  else\n  {\n    v8 = quotearg_style(shell_escape_always_quoting_style, file);\n    v9 = dcgettext(0LL, \"failed to access %s\", 5LL);\n    error(1LL, v6, v9, v8);\n    result = make_dir_parents_private((const char *)1, v6, v10, v11, v12, v13);\n  }\n  return result;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\npush    rbx\nsub     rsp, 38h\nmov     [rbp+var_28], rdi\nmov     [rbp+var_30], rsi\nmov     [rbp+var_38], rdx\nmov     rdx, [rbp+var_30]\nmov     rax, [rbp+var_28]\nmov     rsi, rdx\nmov     rdi, rax\ncall    stat\ntest    eax, eax\njz      short loc_402D88\nloc_402d7f:\ncall    __errno_location\nmov     eax, [rax]\njmp     short loc_402D8D\nloc_402d88:\nmov     eax, 0\nloc_402d8d:\nmov     [rbp+var_14], eax\ncmp     [rbp+var_14], 0\njnz     short loc_402DB0\nloc_402d96:\nmov     rax, [rbp+var_30]\nmov     eax, [rax+18h]\nand     eax, 0F000h\ncmp     eax, 4000h\njnz     short loc_402DB0\nloc_402da9:\nmov     eax, 1\njmp     short loc_402DB5\nloc_402db0:\nmov     eax, 0\nloc_402db5:\nmov     [rbp+var_15], al\nand     [rbp+var_15], 1\ncmp     [rbp+var_14], 0\njz      short loc_402E09\nloc_402dc2:\ncmp     [rbp+var_14], 2\njz      short loc_402E02\nloc_402dc8:\nmov     rax, [rbp+var_28]\nmov     rsi, rax\nmov     edi, 4\ncall    quotearg_style\nmov     rbx, rax\nlea     rdi, aFailedToAccess; \"failed to access %s\"\ncall    gettext\nmov     rdx, rax\nmov     eax, [rbp+var_14]\nmov     rcx, rbx\nmov     esi, eax\nmov     edi, 1\nmov     eax, 0\ncall    error\nloc_402e02:\nmov     rax, [rbp+var_38]\nmov     byte ptr [rax], 1\nloc_402e09:\nmovzx   eax, [rbp+var_15]\nadd     rsp, 38h\npop     rbx\npop     rbp\nretn", "push    r14\nmov     r14, new_dst\nmov     new_dst, st\npush    r13\nmov     r13d, ecx\npush    r12\npush    rbp\nmov     rbp, file\npush    rbx\nmov     rbx, st\nmov     st, file\nmov     edi, 1\ncall    _xstat\ntest    eax, eax\njz      short loc_40269B\nloc_402678:\ncall    __errno_location\nmov     r12d, [rax]\ntest    r12d, r12d\njz      short loc_40269B\nloc_402685:\ncmp     r12d, 2\njz      short loc_4026B4\nloc_40268b:\ntest    r13b, r13b\njz      short loc_4026BC\nloc_402690:\nmov     dword ptr [st+18h], 0\nxor     eax, eax\njmp     short loc_4026AB\nloc_40269b:\nmov     eax, [st+18h]\nand     eax, 0F000h\ncmp     eax, 4000h\nsetz    al\nloc_4026ab:\npop     st\npop     file\npop     r12\npop     r13\npop     new_dst\nretn\nloc_4026b4:\nmov     byte ptr [new_dst], 1\nxor     eax, eax\njmp     short loc_4026AB\nloc_4026bc:\nmov     rsi, file; arg\nmov     edi, 4; s\ncall    quotearg_style\nmov     edx, 5\nmov     st, rax\nmov     esi, offset aFailedToAccess; \"failed to access %s\"\nxor     edi, edi\ncall    dcgettext\nmov     rcx, rbx\nmov     rdx, rax\nmov     esi, r12d\nmov     edi, 1\nxor     eax, eax\ncall    error\nnop     word ptr [rax+rax+00000000h]\nloc_402700:\npush    rbp"]}, {"ea": "00405902", "origin name": "set_file_security_ctx", "ea2": "004042c0", "matched name": "set_file_security_ctx", "ratio": "0.240", "bb1": "16", "bb2": "4", "heuristic": "Same constants", "pseudo": ["signed __int64 __fastcall set_file_security_ctx(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)\n{\n  bool v12; // al\n  bool v13; // al\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  int *v16; // rax\n  unsigned int *v17; // r12\n  const __m128i *v18; // rbx\n  unsigned int *v19; // rax\n  bool v21; // [rsp+2Eh] [rbp-12h]\n  bool v22; // [rsp+2Fh] [rbp-11h]\n\n  v12 = a4[35] != 1 || a4[38];\n  v21 = v12;\n  v13 = !v12 && a4[41] != 1;\n  v22 = v13;\n  if ( !((unsigned __int8)restorecon(a1) ^ 1) )\n    return 1LL;\n  if ( v21 || v22 && (v16 = (int *)_errno_location(), (unsigned __int8)errno_unsupported(*v16) ^ 1) )\n  {\n    v17 = quotearg_n_style(0, 4, a1, a5, a6, a7, a8, v14, v15, a11, a12);\n    v18 = (const __m128i *)gettext((__int64)\"failed to set the security context of %s\");\n    v19 = (unsigned int *)_errno_location();\n    error(0, *v19, v18, v17);\n  }\n  return 0LL;\n}", "_Bool __fastcall set_file_security_ctx(const char *dst_name, _Bool process_local, _Bool recurse, const cp_options *x)\n{\n  _DWORD *v4; // rax\n  unsigned int *v5; // rbx\n  char *v6; // rbp\n  __int64 v7; // rax\n  _Bool result; // al\n\n  if ( x->data_copy_required && !x->require_preserve_context )\n  {\n    *(_DWORD *)_errno_location(dst_name) = 95;\n    result = 0;\n  }\n  else\n  {\n    v4 = (_DWORD *)_errno_location(dst_name);\n    *v4 = 95;\n    v5 = v4;\n    v6 = quotearg_n_style(0, shell_escape_always_quoting_style, dst_name);\n    v7 = dcgettext(0LL, \"failed to set the security context of %s\", 5LL);\n    error(0LL, *v5, v7, v6);\n    result = 0;\n  }\n  return result;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\npush    r12\npush    rbx\nsub     rsp, 30h\nmov     [rbp+var_28], rdi\nmov     eax, edx\nmov     [rbp+var_38], rcx\nmov     [rbp+var_2C], sil\nmov     [rbp+var_30], al\nmov     rax, [rbp+var_38]\nmovzx   eax, byte ptr [rax+23h]\nxor     eax, 1\ntest    al, al\njnz     short loc_405939\nloc_40592d:\nmov     rax, [rbp+var_38]\nmovzx   eax, byte ptr [rax+26h]\ntest    al, al\njz      short loc_405940\nloc_405939:\nmov     eax, 1\njmp     short loc_405945\nloc_405940:\nmov     eax, 0\nloc_405945:\nmov     [rbp+var_12], al\nand     [rbp+var_12], 1\nmovzx   eax, [rbp+var_12]\nxor     eax, 1\ntest    al, al\njz      short loc_40596D\nloc_405957:\nmov     rax, [rbp+var_38]\nmovzx   eax, byte ptr [rax+29h]\nxor     eax, 1\ntest    al, al\njz      short loc_40596D\nloc_405966:\nmov     eax, 1\njmp     short loc_405972\nloc_40596d:\nmov     eax, 0\nloc_405972:\nmov     [rbp+var_11], al\nand     [rbp+var_11], 1\nmovzx   edx, [rbp+var_2C]\nmovzx   ecx, [rbp+var_30]\nmov     rax, [rbp+var_28]\nmov     esi, ecx\nmov     rdi, rax\ncall    restorecon\nxor     eax, 1\ntest    al, al\njz      short loc_405A04\nloc_405996:\ncmp     [rbp+var_12], 0\njnz     short loc_4059B7\nloc_40599c:\ncmp     [rbp+var_11], 0\njz      short loc_4059FD\nloc_4059a2:\ncall    __errno_location\nmov     eax, [rax]\nmov     edi, eax\ncall    errno_unsupported\nxor     eax, 1\ntest    al, al\njz      short loc_4059FD\nloc_4059b7:\nmov     rax, [rbp+var_28]\nmov     rdx, rax\nmov     esi, 4\nmov     edi, 0\ncall    quotearg_n_style\nmov     r12, rax\nlea     rdi, aFailedToSetThe; \"failed to set the security context of %\"...\ncall    gettext\nmov     rbx, rax\ncall    __errno_location\nmov     eax, [rax]\nmov     rcx, r12\nmov     rdx, rbx\nmov     esi, eax\nmov     edi, 0\nmov     eax, 0\ncall    error\nloc_4059fd:\nmov     eax, 0\njmp     short loc_405A09\nloc_405a04:\nmov     eax, 1\nloc_405a09:\nadd     rsp, 30h\npop     rbx\npop     r12\npop     rbp\nretn", "push    rbp\nmov     rbp, dst_name\npush    rbx\nsub     rsp, 8\ncmp     byte ptr [x+23h], 0\njz      short loc_4042D5\nloc_4042cf:\ncmp     byte ptr [x+26h], 0\njz      short loc_404320\nloc_4042d5:\ncall    __errno_location\nmov     rdx, dst_name; arg\nmov     esi, 4; s\nxor     edi, edi; n\nmov     dword ptr [rax], 5Fh\nmov     rbx, rax\ncall    quotearg_n_style\nmov     edx, 5\nmov     esi, offset aFailedToSetThe; \"failed to set the security context of %\"...\nxor     edi, edi\nmov     dst_name, rax\ncall    dcgettext\nmov     esi, [rbx]\nmov     rcx, rbp\nmov     rdx, rax\nxor     edi, edi\nxor     eax, eax\ncall    error\nadd     rsp, 8\nxor     eax, eax\npop     rbx\npop     rbp\nretn\nloc_404320:\ncall    __errno_location\nmov     dword ptr [rax], 5Fh\nadd     rsp, 8\nxor     eax, eax\npop     rbx\npop     dst_name\nretn"]}, {"ea": "00407457", "origin name": "emit_verbose", "ea2": "00403a50", "matched name": "emit_verbose", "ratio": "0.340", "bb1": "3", "bb2": "6", "heuristic": "Same constants", "pseudo": ["__int64 __fastcall emit_verbose(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)\n{\n  unsigned int *v11; // rbx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  unsigned int *v14; // rax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned int *v17; // rbx\n  char *v18; // rax\n  __int64 v20; // [rsp+8h] [rbp-28h]\n\n  v20 = a3;\n  v11 = quotearg_n_style(1u, 4, a2, a4, a5, a6, a7, a8, a9, a10, a11);\n  v14 = quotearg_n_style(0, 4, a1, a4, a5, a6, a7, v12, v13, a10, a11);\n  printf((__int64)\"%s -> %s\", v14, v11);\n  if ( v20 )\n  {\n    v17 = quotearg_style(4, v20, a4, a5, a6, a7, v15, v16, a10, a11);\n    v18 = gettext((__int64)\" (backup: %s)\");\n    printf((__int64)v18, v17);\n  }\n  return putchar_unlocked(0xAu);\n}", "void __fastcall emit_verbose(const char *src, const char *dst, const char *backup_dst_name)\n{\n  const char *v3; // rbx\n  char *v4; // r12\n  char *v5; // rax\n  char *v6; // rbx\n  __int64 v7; // rax\n  __int64 v8; // rcx\n  char *v9; // rax\n\n  v3 = backup_dst_name;\n  v4 = quotearg_n_style(1, shell_escape_always_quoting_style, dst);\n  v5 = quotearg_n_style(0, shell_escape_always_quoting_style, src);\n  _printf_chk(1LL, \"%s -> %s\", v5, v4);\n  if ( v3 )\n  {\n    v6 = quotearg_style(shell_escape_always_quoting_style, v3);\n    v7 = dcgettext(0LL, \" (backup: %s)\", 5LL);\n    _printf_chk(1LL, v7, v6, v8);\n  }\n  v9 = stdout->_IO_write_ptr;\n  if ( v9 >= stdout->_IO_write_end )\n  {\n    _overflow(stdout, 10LL);\n  }\n  else\n  {\n    stdout->_IO_write_ptr = v9 + 1;\n    *v9 = 10;\n  }\n}"], "asm": ["push    rbp\nmov     rbp, rsp\npush    rbx\nsub     rsp, 28h\nmov     [rbp+var_18], rdi\nmov     [rbp+var_20], rsi\nmov     [rbp+var_28], rdx\nmov     rax, [rbp+var_20]\nmov     rdx, rax\nmov     esi, 4\nmov     edi, 1\ncall    quotearg_n_style\nmov     rbx, rax\nmov     rax, [rbp+var_18]\nmov     rdx, rax\nmov     esi, 4\nmov     edi, 0\ncall    quotearg_n_style\nmov     rdx, rbx\nmov     rsi, rax\nlea     rdi, aSS_0; \"%s -> %s\"\nmov     eax, 0\ncall    printf\ncmp     [rbp+var_28], 0\njz      short loc_4074E9\nloc_4074b9:\nmov     rax, [rbp+var_28]\nmov     rsi, rax\nmov     edi, 4\ncall    quotearg_style\nmov     rbx, rax\nlea     rdi, aBackupS; \" (backup: %s)\"\ncall    gettext\nmov     rsi, rbx\nmov     rdi, rax\nmov     eax, 0\ncall    printf\nloc_4074e9:\nmov     edi, 0Ah\ncall    putchar_unlocked\nadd     rsp, 28h\npop     rbx\npop     rbp\nretn", "push    r12\npush    rbp\nmov     rbp, src\nmov     edi, 1; n\npush    rbx\nmov     rbx, backup_dst_name\nmov     backup_dst_name, dst; arg\nmov     esi, 4; s\ncall    quotearg_n_style\nxor     edi, edi; n\nmov     r12, rax\nmov     rdx, src; arg\nmov     esi, 4; s\ncall    quotearg_n_style\nmov     rcx, r12\nmov     rdx, rax\nmov     esi, offset aSS_0; \"%s -> %s\"\nxor     eax, eax\nmov     edi, 1\ncall    __printf_chk\ntest    backup_dst_name, backup_dst_name\njz      short loc_403ACD\nloc_403a9a:\nmov     rsi, backup_dst_name; arg\nmov     edi, 4; s\ncall    quotearg_style\nmov     edx, 5\nmov     backup_dst_name, rax\nmov     esi, offset aBackupS; \" (backup: %s)\"\nxor     edi, edi\ncall    dcgettext\nmov     rdx, rbx\nmov     rsi, rax\nmov     edi, 1\nxor     eax, eax\ncall    __printf_chk\nloc_403acd:\nmov     rdi, cs:stdout\nmov     rax, [rdi+28h]\ncmp     rax, [rdi+30h]\njnb     short loc_403AEE\nloc_403ade:\nlea     rdx, [rax+1]\nmov     [rdi+28h], rdx\nmov     byte ptr [rax], 0Ah\npop     rbx\npop     src\npop     r12\nretn\nloc_403aee:\npop     rbx\npop     src\npop     r12\nmov     esi, 0Ah\njmp     __overflow\nloc_421e20:\nmov     eax, [rdi+0C0h]"]}], "vulnerable matching": [], "statistics": [{"matched": 16, "unmatched": 14}, {"best matching": 7, "partial matching": 4, "unreliable matching": 5, "vulnerable matching": 0}]}