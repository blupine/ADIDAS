{"best matching": [{"ea": "00401280", "origin name": "read_int", "ea2": "00401281", "matched name": "read_int", "ratio": "1.000", "bb1": "7", "bb2": "7", "heuristic": "Same order and hash", "pseudo": ["signed __int64 __fastcall read_int(_QWORD *a1)\n{\n  signed __int64 result; // rax\n  __int64 v2; // rdx\n  unsigned int v3; // edx\n  int v4; // ecx\n  int v5; // esi\n  unsigned int v6; // edx\n\n  result = (unsigned int)*(unsigned __int8 *)*a1 - 48;\n  while ( 1 )\n  {\n    v2 = (*a1)++;\n    v3 = *(unsigned __int8 *)(v2 + 1) - 48;\n    if ( v3 > 9 )\n      break;\n    if ( (signed int)result >= 0 )\n    {\n      if ( (signed int)result > 214748364 )\n      {\n        result = 0xFFFFFFFFLL;\n      }\n      else\n      {\n        v4 = 10 * result;\n        result = 0xFFFFFFFFLL;\n        v5 = 0x7FFFFFFF - v3;\n        v6 = v4 + v3;\n        if ( v5 >= v4 )\n          result = v6;\n      }\n    }\n  }\n  return result;\n}", "signed __int64 __fastcall read_int(_QWORD *a1)\n{\n  signed __int64 result; // rax\n  __int64 v2; // rdx\n  unsigned int v3; // edx\n  int v4; // ecx\n  int v5; // esi\n  unsigned int v6; // edx\n\n  result = (unsigned int)*(unsigned __int8 *)*a1 - 48;\n  while ( 1 )\n  {\n    v2 = (*a1)++;\n    v3 = *(unsigned __int8 *)(v2 + 1) - 48;\n    if ( v3 > 9 )\n      break;\n    if ( (signed int)result >= 0 )\n    {\n      if ( (signed int)result > 214748364 )\n      {\n        result = 0xFFFFFFFFLL;\n      }\n      else\n      {\n        v4 = 10 * result;\n        result = 0xFFFFFFFFLL;\n        v5 = 0x7FFFFFFF - v3;\n        v6 = v4 + v3;\n        if ( v5 >= v4 )\n          result = v6;\n      }\n    }\n  }\n  return result;\n}"], "asm": ["mov     rax, [rdi]\nmov     r8d, 7FFFFFFFh\nmovzx   eax, byte ptr [rax]\nsub     eax, 30h\nloc_40128f:\nmov     rdx, [rdi]\nlea     rcx, [rdx+1]\nmov     [rdi], rcx\nmovzx   edx, byte ptr [rdx+1]\nsub     edx, 30h\ncmp     edx, 9\nja      short locret_4012C9\nloc_4012a5:\ntest    eax, eax\njs      short loc_40128F\nloc_4012a9:\ncmp     eax, 0CCCCCCCh\njg      short loc_4012C4\nloc_4012b0:\nimul    ecx, eax, 0Ah\nmov     esi, r8d\nor      eax, 0FFFFFFFFh\nsub     esi, edx\nadd     edx, ecx\ncmp     esi, ecx\ncmovge  eax, edx\njmp     short loc_40128F\nloc_4012c4:\nor      eax, 0FFFFFFFFh\njmp     short loc_40128F\nloc_4012c9:\nretn", "mov     rax, [rdi]\nmov     r8d, 7FFFFFFFh\nmovzx   eax, byte ptr [rax]\nsub     eax, 30h\nloc_401290:\nmov     rdx, [rdi]\nlea     rcx, [rdx+1]\nmov     [rdi], rcx\nmovzx   edx, byte ptr [rdx+1]\nsub     edx, 30h\ncmp     edx, 9\nja      short locret_4012CA\nloc_4012a6:\ntest    eax, eax\njs      short loc_401290\nloc_4012aa:\ncmp     eax, 0CCCCCCCh\njg      short loc_4012C5\nloc_4012b1:\nimul    ecx, eax, 0Ah\nmov     esi, r8d\nor      eax, 0FFFFFFFFh\nsub     esi, edx\nadd     edx, ecx\ncmp     esi, ecx\ncmovge  eax, edx\njmp     short loc_401290\nloc_4012c5:\nor      eax, 0FFFFFFFFh\njmp     short loc_401290\nloc_4012ca:\nretn"]}, {"ea": "004017d2", "origin name": "read_int_0", "ea2": "004017d3", "matched name": "read_int_0", "ratio": "1.000", "bb1": "8", "bb2": "8", "heuristic": "Same order and hash", "pseudo": ["signed __int64 __fastcall read_int_0(_QWORD *a1)\n{\n  _DWORD *v1; // rdx\n  signed __int64 result; // rax\n  unsigned int v3; // ecx\n  int v4; // esi\n  int v5; // er8\n  unsigned int v6; // ecx\n\n  v1 = (_DWORD *)(*a1 + 4LL);\n  result = (unsigned int)(*(_DWORD *)*a1 - 48);\n  while ( 1 )\n  {\n    v3 = *v1 - 48;\n    if ( v3 > 9 )\n      break;\n    if ( (signed int)result >= 0 )\n    {\n      if ( (signed int)result > 214748364 )\n      {\n        result = 0xFFFFFFFFLL;\n      }\n      else\n      {\n        v4 = 10 * result;\n        result = 0xFFFFFFFFLL;\n        v5 = 0x7FFFFFFF - v3;\n        v6 = v4 + v3;\n        if ( v5 >= v4 )\n          result = v6;\n      }\n    }\n    ++v1;\n  }\n  *a1 = v1;\n  return result;\n}", "signed __int64 __fastcall read_int_0(_QWORD *a1)\n{\n  _DWORD *v1; // rdx\n  signed __int64 result; // rax\n  unsigned int v3; // ecx\n  int v4; // esi\n  int v5; // er8\n  unsigned int v6; // ecx\n\n  v1 = (_DWORD *)(*a1 + 4LL);\n  result = (unsigned int)(*(_DWORD *)*a1 - 48);\n  while ( 1 )\n  {\n    v3 = *v1 - 48;\n    if ( v3 > 9 )\n      break;\n    if ( (signed int)result >= 0 )\n    {\n      if ( (signed int)result > 214748364 )\n      {\n        result = 0xFFFFFFFFLL;\n      }\n      else\n      {\n        v4 = 10 * result;\n        result = 0xFFFFFFFFLL;\n        v5 = 0x7FFFFFFF - v3;\n        v6 = v4 + v3;\n        if ( v5 >= v4 )\n          result = v6;\n      }\n    }\n    ++v1;\n  }\n  *a1 = v1;\n  return result;\n}"], "asm": ["mov     rdx, [rdi]\nmov     r9d, 7FFFFFFFh\nmov     eax, [rdx]\nadd     rdx, 4\nsub     eax, 30h\nloc_4017e4:\nmov     esi, [rdx]\nlea     ecx, [rsi-30h]\ncmp     ecx, 9\nja      short loc_401818\nloc_4017ee:\ntest    eax, eax\njs      short loc_401812\nloc_4017f2:\ncmp     eax, 0CCCCCCCh\njg      short loc_40180F\nloc_4017f9:\nimul    esi, eax, 0Ah\nmov     r8d, r9d\nor      eax, 0FFFFFFFFh\nsub     r8d, ecx\nadd     ecx, esi\ncmp     r8d, esi\ncmovge  eax, ecx\njmp     short loc_401812\nloc_40180f:\nor      eax, 0FFFFFFFFh\nloc_401812:\nadd     rdx, 4\njmp     short loc_4017E4\nloc_401818:\nmov     [rdi], rdx\nretn", "mov     rdx, [rdi]\nmov     r9d, 7FFFFFFFh\nmov     eax, [rdx]\nadd     rdx, 4\nsub     eax, 30h\nloc_4017e5:\nmov     esi, [rdx]\nlea     ecx, [rsi-30h]\ncmp     ecx, 9\nja      short loc_401819\nloc_4017ef:\ntest    eax, eax\njs      short loc_401813\nloc_4017f3:\ncmp     eax, 0CCCCCCCh\njg      short loc_401810\nloc_4017fa:\nimul    esi, eax, 0Ah\nmov     r8d, r9d\nor      eax, 0FFFFFFFFh\nsub     r8d, ecx\nadd     ecx, esi\ncmp     r8d, esi\ncmovge  eax, ecx\njmp     short loc_401813\nloc_401810:\nor      eax, 0FFFFFFFFh\nloc_401813:\nadd     rdx, 4\njmp     short loc_4017E5\nloc_401819:\nmov     [rdi], rdx\nretn"]}, {"ea": "00401d80", "origin name": "frame_dummy", "ea2": "004024c0", "matched name": "frame_dummy", "ratio": "1.000", "bb1": "7", "bb2": "7", "heuristic": "Equal pseudo-code", "pseudo": ["__int64 frame_dummy()\n{\n  if ( _register_frame_info )\n    _register_frame_info(&_EH_FRAME_BEGIN__, &object_6475);\n  return register_tm_clones();\n}", "__int64 frame_dummy()\n{\n  if ( _register_frame_info )\n    _register_frame_info(&_EH_FRAME_BEGIN__, &object_6475);\n  return register_tm_clones();\n}"], "asm": ["push    rbp\nmov     eax, offset __register_frame_info\ntest    rax, rax\nmov     rbp, rsp\njz      short loc_401D9D\nloc_401d10:\nmov     eax, offset _edata\nloc_401d8e:\nmov     esi, offset object_6475\nmov     edi, offset __EH_FRAME_BEGIN__\ncall    __register_frame_info\nloc_401d9d:\ncmp     cs:__JCR_LIST__, 0\njz      short loc_401DB8\nloc_401da7:\nmov     eax, 0\ntest    rax, rax\njz      short loc_401DB8\nloc_401db1:\nmov     edi, offset __JCR_LIST__\ncall    rax\nloc_401db8:\npop     rbp\njmp     register_tm_clones", "push    rbp\nmov     eax, offset __register_frame_info\ntest    rax, rax\nmov     rbp, rsp\njz      short loc_4024DD\nloc_402450:\nmov     eax, offset _edata\nloc_4024ce:\nmov     esi, offset object_6475\nmov     edi, offset __EH_FRAME_BEGIN__\ncall    __register_frame_info\nloc_4024dd:\ncmp     cs:__JCR_LIST__, 0\njz      short loc_4024F8\nloc_4024e7:\nmov     eax, 0\ntest    rax, rax\njz      short loc_4024F8\nloc_4024f1:\nmov     edi, offset __JCR_LIST__\ncall    rax\nloc_4024f8:\npop     rbp\njmp     register_tm_clones"]}, {"ea": "00401266", "origin name": "__gconv_release_step.part.1", "ea2": "00401267", "matched name": "__gconv_release_step.part.1", "ratio": "1.000", "bb1": "1", "bb2": "1", "heuristic": "Equal assembly", "pseudo": ["void __fastcall __noreturn _gconv_release_step_part_1(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)\n{\n  _assert_fail(\n    (__int64)\"step->__end_fct == ((void *)0)\",\n    (__int64)\"gconv_db.c\",\n    0xEBu,\n    \"__gconv_release_step\",\n    a1,\n    a2,\n    a3,\n    a4,\n    a5,\n    a6,\n    a7,\n    a8);\n}", "void __fastcall __noreturn _gconv_release_step_part_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  _assert_fail(\"step->__end_fct == ((void *)0)\", \"gconv_db.c\", 235LL, \"__gconv_release_step\", a5, a6);\n}"], "asm": ["push    rax\nmov     ecx, offset __PRETTY_FUNCTION___9843; \"__gconv_release_step\"\nmov     edx, 0EBh\nmov     esi, offset aGconvDbC; \"gconv_db.c\"\nmov     edi, offset aStepEndFctVoid; \"step->__end_fct == ((void *)0)\"\ncall    __assert_fail", "push    rax\nmov     ecx, offset __PRETTY_FUNCTION___9843; \"__gconv_release_step\"\nmov     edx, 0EBh\nmov     esi, offset aGconvDbC; \"gconv_db.c\"\nmov     edi, offset aStepEndFctVoid; \"step->__end_fct == ((void *)0)\"\ncall    __assert_fail"]}, {"ea": "00401cae", "origin name": "_start", "ea2": "004023ee", "matched name": "_start", "ratio": "1.000", "bb1": "1", "bb2": "1", "heuristic": "Equal assembly", "pseudo": ["None\nNone", "None\nNone"], "asm": ["xor     ebp, ebp\nmov     r9, rdx; rtld_fini\npop     rsi; argc\nmov     rdx, rsp; ubp_av\nand     rsp, 0FFFFFFFFFFFFFFF0h\npush    rax\npush    rsp; stack_end\nmov     r8, offset __libc_csu_fini; fini\nmov     rcx, offset __libc_csu_init; init\nmov     rdi, offset main; main\ncall    __libc_start_main", "xor     ebp, ebp\nmov     r9, rdx; rtld_fini\npop     rsi; argc\nmov     rdx, rsp; ubp_av\nand     rsp, 0FFFFFFFFFFFFFFF0h\npush    rax\npush    rsp; stack_end\nmov     r8, offset __libc_csu_fini; fini\nmov     rcx, offset __libc_csu_init; init\nmov     rdi, offset main; main\ncall    __libc_start_main"]}, {"ea": "00401a20", "origin name": "fini", "ea2": "00401a20", "matched name": "fini", "ratio": "1.000", "bb1": "5", "bb2": "5", "heuristic": "Same address, nodes, edges and mnemonics", "pseudo": ["void __fastcall fini(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)\n{\n  if ( qword_6FF038 )\n  {\n    if ( memcmp((const void *)qword_6FF038, \"out of memory\", 0xEuLL) )\n      free(qword_6FF038);\n  }\n}", "void fini()\n{\n  if ( qword_6FBFB8 )\n  {\n    if ( memcmp(qword_6FBFB8, \"out of memory\", 0xEuLL) )\n      free(qword_6FBFB8);\n  }\n}"], "asm": ["mov     rax, cs:qword_6FF038\ntest    rax, rax\njz      short locret_401A3D\nloc_401a2c:\nmov     edi, offset _dl_out_of_memory; \"out of memory\"\nmov     ecx, 0Eh\nmov     rsi, rax\nrepe cmpsb\njnz     short loc_401A3E\nloc_401a3d:\nretn\nloc_401a3e:\nmov     rdi, rax\njmp     free\nloc_42da90:\nmov     rax, cs:__free_hook", "mov     rax, cs:qword_6FBFB8\ntest    rax, rax\njz      short locret_401A3D\nloc_401a2c:\nmov     edi, offset _dl_out_of_memory; \"out of memory\"\nmov     ecx, 0Eh\nmov     rsi, rax\nrepe cmpsb\njnz     short loc_401A3E\nloc_401a3d:\nretn\nloc_401a3e:\nmov     rdi, rax; void *\njmp     free\nloc_429bd0:\nmov     rax, cs:__free_hook"]}, {"ea": "00401a50", "origin name": "init_cacheinfo", "ea2": "00402190", "matched name": "init_cacheinfo", "ratio": "1.000", "bb1": "41", "bb2": "41", "heuristic": "Same constants", "pseudo": ["__int64 __fastcall init_cacheinfo(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)\n{\n  __int64 result; // rax\n  signed __int64 v9; // r12\n  double v10; // xmm4_8\n  double v11; // xmm5_8\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  signed __int64 v14; // rbp\n  signed int v15; // er8\n  int i; // ecx\n  int v17; // edi\n  __int64 v22; // r11\n  signed __int64 v23; // rax\n  signed __int64 v24; // rax\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  double v27; // xmm4_8\n  double v28; // xmm5_8\n  signed __int64 v29; // rdi\n  unsigned int v34; // esi\n  __int64 v39; // rbx\n  unsigned int v49; // esi\n  int j; // ecx\n  int v51; // edi\n  int v56; // ecx\n  int v57; // ecx\n\n  result = (unsigned int)_cpu_features;\n  if ( !_cpu_features )\n  {\n    _init_cpu_features();\n    result = (unsigned int)_cpu_features;\n  }\n  if ( (_DWORD)result == 1 )\n  {\n    v9 = handle_intel(188, dword_6FF964, a1, a2, a3, a4, a5, a6, a7, a8);\n    result = handle_intel(194, dword_6FF964, a1, a2, a3, a4, v10, v11, a7, a8);\n    v14 = result;\n    v15 = 3;\n    if ( result <= 0 )\n    {\n      result = handle_intel(191, dword_6FF964, a1, a2, a3, a4, v12, v13, a7, a8);\n      v15 = 2;\n      v14 = result;\n    }\n    if ( dword_6FF964 > 3 )\n    {\n      for ( i = 0; ; i = v17 )\n      {\n        v17 = i + 1;\n        _RAX = 4LL;\n        __asm { cpuid }\n        if ( !(result & 0x1F) )\n          break;\n        if ( (unsigned __int8)result >> 5 == v15 )\n        {\n          result = (unsigned int)result >> 14;\n          v49 = result & 0x3FF;\n          if ( result & 0x3FF && dword_6FF964 > 10 )\n          {\n            for ( j = 0; ; j = v51 )\n            {\n              v51 = j + 1;\n              _RAX = 11LL;\n              __asm { cpuid }\n              v56 = _RCX & 0xFF0;\n              if ( !v56 || !(_BYTE)_RBX )\n                break;\n              if ( v56 == 512 )\n              {\n                _BitScanReverse((unsigned int *)&v57, v49);\n                v49 = ((unsigned __int8)_RBX - 1) & ~(-1 << (v57 + 1));\n                break;\n              }\n            }\n          }\n          v22 = v49 + 1;\n          goto LABEL_14;\n        }\n      }\n    }\n    v22 = BYTE2(dword_6FF96C);\nLABEL_14:\n    if ( (_DWORD)v22 && v14 > 0 )\n    {\n      result = v14 / v22;\n      v14 /= v22;\n    }\n    goto LABEL_17;\n  }\n  if ( (_DWORD)result != 2 )\n    return result;\n  v9 = handle_amd(188, a1, a2, a3, a4, a5, a6, a7, a8);\n  v14 = handle_amd(191, a1, a2, a3, a4, v25, v26, a7, a8);\n  v29 = handle_amd(194, a1, a2, a3, a4, v27, v28, a7, a8);\n  _RAX = 0x80000000LL;\n  __asm { cpuid }\n  v34 = result;\n  if ( v29 > 0 )\n  {\n    if ( (unsigned int)result > 0x80000007 )\n    {\n      _RAX = 2147483656LL;\n      __asm { cpuid }\n      v34 = _RAX;\n      v39 = (unsigned int)(1 << ((unsigned __int16)_RCX >> 12));\n    }\n    else\n    {\n      _RAX = 1LL;\n      __asm { cpuid }\n      v34 = result;\n      if ( !(_RDX & 0x10000000) )\n        goto LABEL_25;\n      v39 = BYTE2(_RBX);\n      if ( !(_DWORD)v39 )\n        goto LABEL_25;\n    }\n    result = v29 / v39;\n    v29 /= v39;\nLABEL_25:\n    v14 += v29;\n  }\n  if ( v34 > 0x80000000 )\n  {\n    _RAX = 2147483649LL;\n    __asm { cpuid }\n    if ( _RCX & 0x100 || (signed int)_RDX < 0 )\n      _x86_prefetchw = -1;\n  }\nLABEL_17:\n  if ( v9 > 0 )\n  {\n    v23 = v9;\n    _x86_raw_data_cache_size = v9;\n    LOBYTE(v9) = 0;\n    _x86_data_cache_size = v9;\n    _x86_raw_data_cache_size_half = v23 >> 1;\n    result = v9 >> 1;\n    _x86_data_cache_size_half = v9 >> 1;\n  }\n  if ( v14 > 0 )\n  {\n    v24 = v14;\n    _x86_raw_shared_cache_size = v14;\n    LOBYTE(v14) = 0;\n    _x86_shared_cache_size = v14;\n    _x86_raw_shared_cache_size_half = v24 >> 1;\n    result = v14 >> 1;\n    _x86_shared_cache_size_half = v14 >> 1;\n  }\n  return result;\n}", "__int64 init_cacheinfo()\n{\n  __int64 result; // rax\n  __int64 v1; // r12\n  __int64 v2; // rbp\n  signed int v3; // er8\n  int i; // ecx\n  int v5; // edi\n  __int64 v10; // r11\n  __int64 v11; // rax\n  __int64 v12; // rax\n  __int64 v13; // rdi\n  unsigned int v18; // esi\n  __int64 v23; // rbx\n  int v33; // esi\n  int j; // ecx\n  int v35; // edi\n  int v40; // ecx\n  int v41; // ecx\n\n  result = (unsigned int)_cpu_features;\n  if ( !_cpu_features )\n  {\n    _init_cpu_features();\n    result = (unsigned int)_cpu_features;\n  }\n  if ( (_DWORD)result == 1 )\n  {\n    v1 = handle_intel(188LL, (unsigned int)dword_6FC8E4);\n    result = handle_intel(194LL, (unsigned int)dword_6FC8E4);\n    v2 = result;\n    v3 = 3;\n    if ( result <= 0 )\n    {\n      result = handle_intel(191LL, (unsigned int)dword_6FC8E4);\n      v3 = 2;\n      v2 = result;\n    }\n    if ( dword_6FC8E4 > 3 )\n    {\n      for ( i = 0; ; i = v5 )\n      {\n        v5 = i + 1;\n        _RAX = 4LL;\n        __asm { cpuid }\n        if ( !(result & 0x1F) )\n          break;\n        if ( (unsigned __int8)result >> 5 == v3 )\n        {\n          result = (unsigned int)result >> 14;\n          v33 = result & 0x3FF;\n          if ( result & 0x3FF && dword_6FC8E4 > 10 )\n          {\n            for ( j = 0; ; j = v35 )\n            {\n              v35 = j + 1;\n              _RAX = 11LL;\n              __asm { cpuid }\n              v40 = _RCX & 0xFF0;\n              if ( !v40 || !(_BYTE)_RBX )\n                break;\n              if ( v40 == 512 )\n              {\n                _BitScanReverse((unsigned int *)&v41, v33);\n                v33 = ((unsigned __int8)_RBX - 1) & ~(-1 << (v41 + 1));\n                break;\n              }\n            }\n          }\n          v10 = (unsigned int)(v33 + 1);\n          goto LABEL_14;\n        }\n      }\n    }\n    v10 = BYTE2(dword_6FC8EC);\nLABEL_14:\n    if ( (_DWORD)v10 && v2 > 0 )\n    {\n      result = v2 / v10;\n      v2 /= v10;\n    }\n    goto LABEL_17;\n  }\n  if ( (_DWORD)result != 2 )\n    return result;\n  v1 = handle_amd(188LL);\n  v2 = handle_amd(191LL);\n  v13 = handle_amd(194LL);\n  _RAX = 0x80000000LL;\n  __asm { cpuid }\n  v18 = result;\n  if ( v13 > 0 )\n  {\n    if ( (unsigned int)result > 0x80000007 )\n    {\n      _RAX = 2147483656LL;\n      __asm { cpuid }\n      v18 = _RAX;\n      v23 = (unsigned int)(1 << ((unsigned __int16)_RCX >> 12));\n    }\n    else\n    {\n      _RAX = 1LL;\n      __asm { cpuid }\n      v18 = result;\n      if ( !(_RDX & 0x10000000) )\n        goto LABEL_25;\n      v23 = BYTE2(_RBX);\n      if ( !(_DWORD)v23 )\n        goto LABEL_25;\n    }\n    result = v13 / v23;\n    v13 /= v23;\nLABEL_25:\n    v2 += v13;\n  }\n  if ( v18 > 0x80000000 )\n  {\n    _RAX = 2147483649LL;\n    __asm { cpuid }\n    if ( _RCX & 0x100 || (signed int)_RDX < 0 )\n      _x86_prefetchw = -1;\n  }\nLABEL_17:\n  if ( v1 > 0 )\n  {\n    v11 = v1;\n    _x86_raw_data_cache_size = v1;\n    LOBYTE(v1) = 0;\n    _x86_data_cache_size = v1;\n    _x86_raw_data_cache_size_half = v11 >> 1;\n    result = v1 >> 1;\n    _x86_data_cache_size_half = v1 >> 1;\n  }\n  if ( v2 > 0 )\n  {\n    v12 = v2;\n    _x86_raw_shared_cache_size = v2;\n    LOBYTE(v2) = 0;\n    _x86_shared_cache_size = v2;\n    _x86_raw_shared_cache_size_half = v12 >> 1;\n    result = v2 >> 1;\n    _x86_shared_cache_size_half = v2 >> 1;\n  }\n  return result;\n}"], "asm": ["push    r12\nmov     eax, cs:__cpu_features\npush    rbp\ntest    eax, eax\npush    rbx\njz      short loc_401A71\nloc_401a5e:\ncmp     eax, 1\njz      short loc_401A7E\nloc_401a63:\ncmp     eax, 2\njz      loc_401B81\nloc_401a6c:\npop     rbx\npop     rbp\npop     r12\nretn\nloc_401a71:\ncall    __init_cpu_features\nmov     eax, cs:__cpu_features\njmp     short loc_401A5E\nloc_401a7e:\nmov     esi, cs:dword_6FF964\nmov     edi, 0BCh\ncall    handle_intel\nmov     esi, cs:dword_6FF964\nmov     edi, 0C2h\nmov     r12, rax\ncall    handle_intel\ntest    rax, rax\nmov     rbp, rax\nmov     r8d, 3\njle     loc_401C7C\nloc_401ab3:\nmov     r10d, cs:dword_6FF964\nmov     r11d, cs:dword_6FF96C\ncmp     r10d, 3\njle     short loc_401AF7\nloc_401ac7:\nxor     ecx, ecx\nmov     r9d, 4\njmp     short loc_401AEB\nloc_401ad8:\nmov     edx, eax\nshr     edx, 5\nand     edx, 7\ncmp     edx, r8d\njz      loc_401C35\nloc_401ae9:\nmov     ecx, edi\nloc_401aeb:\nlea     edi, [rcx+1]\nmov     eax, r9d\ncpuid\ntest    al, 1Fh\njnz     short loc_401AD8\nloc_401af7:\nshr     r11d, 10h\nmovzx   r11d, r11b\nloc_401aff:\ntest    r11d, r11d\njz      short loc_401B09\nloc_401b04:\ntest    rbp, rbp\njg      short loc_401B74\nloc_401b09:\ntest    r12, r12\njle     short loc_401B3A\nloc_401b0e:\nmov     rax, r12\nmov     cs:__x86_raw_data_cache_size, r12\nand     r12b, 0\nsar     rax, 1\nmov     cs:__x86_data_cache_size, r12\nmov     cs:__x86_raw_data_cache_size_half, rax\nmov     rax, r12\nsar     rax, 1\nmov     cs:__x86_data_cache_size_half, rax\nloc_401b3a:\ntest    rbp, rbp\njle     loc_401A6C\nloc_401b43:\nmov     rax, rbp\nmov     cs:__x86_raw_shared_cache_size, rbp\nand     bpl, 0\nsar     rax, 1\nmov     cs:__x86_shared_cache_size, rbp\npop     rbx\nmov     cs:__x86_raw_shared_cache_size_half, rax\nmov     rax, rbp\nsar     rax, 1\npop     rbp\nmov     cs:__x86_shared_cache_size_half, rax\npop     r12\nretn\nloc_401b74:\nmov     rax, rbp\ncqo\nidiv    r11\nmov     rbp, rax\njmp     short loc_401B09\nloc_401b81:\nmov     edi, 0BCh\ncall    handle_amd\nmov     edi, 0BFh\nmov     r12, rax\ncall    handle_amd\nmov     edi, 0C2h\nmov     rbp, rax\ncall    handle_amd\nmov     esi, 80000000h\nmov     rdi, rax\nmov     eax, esi\ncpuid\ntest    rdi, rdi\nmov     esi, eax\njle     short loc_401BDF\nloc_401bb8:\ncmp     eax, 80000007h\nja      short loc_401C06\nloc_401bbf:\nmov     esi, 1\nmov     eax, esi\ncpuid\nand     edx, 10000000h\nmov     esi, eax\njz      short loc_401BDC\nloc_401bd2:\nshr     ebx, 10h\nmovzx   ebx, bl\ntest    ebx, ebx\njnz     short loc_401C1E\nloc_401bdc:\nadd     rbp, rdi\nloc_401bdf:\ncmp     esi, 80000000h\njbe     loc_401B09\nloc_401beb:\nmov     eax, 80000001h\ncpuid\nand     ch, 1\njz      short loc_401C2B\nloc_401bf7:\nmov     cs:__x86_prefetchw, 0FFFFFFFFh\njmp     loc_401B09\nloc_401c06:\nmov     esi, 80000008h\nmov     eax, esi\ncpuid\nshr     ecx, 0Ch\nmov     ebx, 1\nmov     esi, eax\nand     ecx, 0Fh\nshl     ebx, cl\nloc_401c1e:\nmov     rax, rdi\ncqo\nidiv    rbx\nmov     rdi, rax\njmp     short loc_401BDC\nloc_401c2b:\ntest    edx, edx\njns     loc_401B09\nloc_401c33:\njmp     short loc_401BF7\nloc_401c35:\nshr     eax, 0Eh\nmov     esi, eax\nand     esi, 3FFh\njz      short loc_401C73\nloc_401c42:\ncmp     r10d, 0Ah\njle     short loc_401C73\nloc_401c48:\nxor     ecx, ecx\nmov     r8d, 0Bh\njmp     short loc_401C60\nloc_401c52:\ntest    ebx, ebx\njz      short loc_401C73\nloc_401c56:\ncmp     ecx, 200h\njz      short loc_401C9A\nloc_401c5e:\nmov     ecx, edi\nloc_401c60:\nlea     edi, [rcx+1]\nmov     eax, r8d\ncpuid\nand     ecx, 0FF0h\nmovzx   ebx, bl\njnz     short loc_401C52\nloc_401c73:\nlea     r11d, [rsi+1]\njmp     loc_401AFF\nloc_401c7c:\nmov     esi, cs:dword_6FF964\nmov     edi, 0BFh\ncall    handle_intel\nmov     r8d, 2\nmov     rbp, rax\njmp     loc_401AB3\nloc_401c9a:\nbsr     ecx, esi\nor      esi, 0FFFFFFFFh\nadd     ecx, 1\nsub     ebx, 1\nshl     esi, cl\nnot     esi\nand     esi, ebx\njmp     short loc_401C73", "push    r12\nmov     eax, cs:__cpu_features\npush    rbp\ntest    eax, eax\npush    rbx\njz      short loc_4021B1\nloc_40219e:\ncmp     eax, 1\njz      short loc_4021BE\nloc_4021a3:\ncmp     eax, 2\njz      loc_4022C1\nloc_4021ac:\npop     rbx\npop     rbp\npop     r12\nretn\nloc_4021b1:\ncall    __init_cpu_features\nmov     eax, cs:__cpu_features\njmp     short loc_40219E\nloc_4021be:\nmov     esi, cs:dword_6FC8E4\nmov     edi, 0BCh\ncall    handle_intel\nmov     esi, cs:dword_6FC8E4\nmov     edi, 0C2h\nmov     r12, rax\ncall    handle_intel\ntest    rax, rax\nmov     rbp, rax\nmov     r8d, 3\njle     loc_4023BC\nloc_4021f3:\nmov     r10d, cs:dword_6FC8E4\nmov     r11d, cs:dword_6FC8EC\ncmp     r10d, 3\njle     short loc_402237\nloc_402207:\nxor     ecx, ecx\nmov     r9d, 4\njmp     short loc_40222B\nloc_402218:\nmov     edx, eax\nshr     edx, 5\nand     edx, 7\ncmp     edx, r8d\njz      loc_402375\nloc_402229:\nmov     ecx, edi\nloc_40222b:\nlea     edi, [rcx+1]\nmov     eax, r9d\ncpuid\ntest    al, 1Fh\njnz     short loc_402218\nloc_402237:\nshr     r11d, 10h\nmovzx   r11d, r11b\nloc_40223f:\ntest    r11d, r11d\njz      short loc_402249\nloc_402244:\ntest    rbp, rbp\njg      short loc_4022B4\nloc_402249:\ntest    r12, r12\njle     short loc_40227A\nloc_40224e:\nmov     rax, r12\nmov     cs:__x86_raw_data_cache_size, r12\nand     r12b, 0\nsar     rax, 1\nmov     cs:__x86_data_cache_size, r12\nmov     cs:__x86_raw_data_cache_size_half, rax\nmov     rax, r12\nsar     rax, 1\nmov     cs:__x86_data_cache_size_half, rax\nloc_40227a:\ntest    rbp, rbp\njle     loc_4021AC\nloc_402283:\nmov     rax, rbp\nmov     cs:__x86_raw_shared_cache_size, rbp\nand     bpl, 0\nsar     rax, 1\nmov     cs:__x86_shared_cache_size, rbp\npop     rbx\nmov     cs:__x86_raw_shared_cache_size_half, rax\nmov     rax, rbp\nsar     rax, 1\npop     rbp\nmov     cs:__x86_shared_cache_size_half, rax\npop     r12\nretn\nloc_4022b4:\nmov     rax, rbp\ncqo\nidiv    r11\nmov     rbp, rax\njmp     short loc_402249\nloc_4022c1:\nmov     edi, 0BCh\ncall    handle_amd\nmov     edi, 0BFh\nmov     r12, rax\ncall    handle_amd\nmov     edi, 0C2h\nmov     rbp, rax\ncall    handle_amd\nmov     esi, 80000000h\nmov     rdi, rax\nmov     eax, esi\ncpuid\ntest    rdi, rdi\nmov     esi, eax\njle     short loc_40231F\nloc_4022f8:\ncmp     eax, 80000007h\nja      short loc_402346\nloc_4022ff:\nmov     esi, 1\nmov     eax, esi\ncpuid\nand     edx, 10000000h\nmov     esi, eax\njz      short loc_40231C\nloc_402312:\nshr     ebx, 10h\nmovzx   ebx, bl\ntest    ebx, ebx\njnz     short loc_40235E\nloc_40231c:\nadd     rbp, rdi\nloc_40231f:\ncmp     esi, 80000000h\njbe     loc_402249\nloc_40232b:\nmov     eax, 80000001h\ncpuid\nand     ch, 1\njz      short loc_40236B\nloc_402337:\nmov     cs:__x86_prefetchw, 0FFFFFFFFh\njmp     loc_402249\nloc_402346:\nmov     esi, 80000008h\nmov     eax, esi\ncpuid\nshr     ecx, 0Ch\nmov     ebx, 1\nmov     esi, eax\nand     ecx, 0Fh\nshl     ebx, cl\nloc_40235e:\nmov     rax, rdi\ncqo\nidiv    rbx\nmov     rdi, rax\njmp     short loc_40231C\nloc_40236b:\ntest    edx, edx\njns     loc_402249\nloc_402373:\njmp     short loc_402337\nloc_402375:\nshr     eax, 0Eh\nmov     esi, eax\nand     esi, 3FFh\njz      short loc_4023B3\nloc_402382:\ncmp     r10d, 0Ah\njle     short loc_4023B3\nloc_402388:\nxor     ecx, ecx\nmov     r8d, 0Bh\njmp     short loc_4023A0\nloc_402392:\ntest    ebx, ebx\njz      short loc_4023B3\nloc_402396:\ncmp     ecx, 200h\njz      short loc_4023DA\nloc_40239e:\nmov     ecx, edi\nloc_4023a0:\nlea     edi, [rcx+1]\nmov     eax, r8d\ncpuid\nand     ecx, 0FF0h\nmovzx   ebx, bl\njnz     short loc_402392\nloc_4023b3:\nlea     r11d, [rsi+1]\njmp     loc_40223F\nloc_4023bc:\nmov     esi, cs:dword_6FC8E4\nmov     edi, 0BFh\ncall    handle_intel\nmov     r8d, 2\nmov     rbp, rax\njmp     loc_4021F3\nloc_4023da:\nbsr     ecx, esi\nor      esi, 0FFFFFFFFh\nadd     ecx, 1\nsub     ebx, 1\nshl     esi, cl\nnot     esi\nand     esi, ebx\njmp     short loc_4023B3"]}, {"ea": "0040181c", "origin name": "group_number_0", "ea2": "0040181d", "matched name": "group_number_0", "ratio": "1.000", "bb1": "16", "bb2": "16", "heuristic": "Import names hash", "pseudo": ["char *__fastcall group_number_0(char *a1, char *a2, _BYTE *a3, int a4)\n{\n  int v4; // er14\n  int v5; // ebx\n  char *result; // rax\n  _BYTE *v7; // r13\n  void *v8; // rsp\n  unsigned __int64 v9; // r12\n  _DWORD *v10; // rax\n  char *v11; // r8\n  char v12; // [rsp+7h] [rbp-21h]\n\n  v4 = a4;\n  v5 = (char)*a3;\n  result = a1;\n  if ( (unsigned __int8)(*a3 - 1) > 0x7Du )\n    return result;\n  v7 = a3 + 1;\n  v8 = alloca(a2 - a1 + 15);\n  v9 = (unsigned __int64)&v12 & 0xFFFFFFFFFFFFFFF0LL;\n  mempcpy((unsigned __int64)&v12 & 0xFFFFFFFFFFFFFFF0LL, a1, a2 - a1);\n  while ( 1 )\n  {\n    if ( (unsigned __int64)v10 <= v9 )\n      return a2;\n    --v10;\n    --v5;\n    v11 = a2 - 4;\n    *((_DWORD *)a2 - 1) = *v10;\n    if ( !v5 && (unsigned __int64)v10 > v9 )\n      break;\nLABEL_13:\n    a2 = v11;\n  }\n  *((_DWORD *)a2 - 2) = v4;\n  v5 = (char)*v7;\n  v11 = a2 - 8;\n  if ( *v7 >= 0 && (_BYTE)v5 != 127 )\n  {\n    if ( (_BYTE)v5 )\n      ++v7;\n    else\n      v5 = (char)*(v7 - 1);\n    goto LABEL_13;\n  }\n  do\n  {\n    --v10;\n    v11 -= 4;\n    *(_DWORD *)v11 = *v10;\n  }\n  while ( (unsigned __int64)v10 > v9 );\n  return v11;\n}", "char *__fastcall group_number_0(char *a1, char *a2, _BYTE *a3, int a4)\n{\n  int v4; // er14\n  int v5; // ebx\n  char *result; // rax\n  _BYTE *v7; // r13\n  void *v8; // rsp\n  unsigned __int64 v9; // r12\n  _DWORD *v10; // rax\n  char *v11; // r8\n  char v12; // [rsp-29h] [rbp-29h]\n\n  v4 = a4;\n  v5 = (char)*a3;\n  result = a1;\n  if ( (unsigned __int8)(*a3 - 1) > 0x7Du )\n    return result;\n  v7 = a3 + 1;\n  v8 = alloca(a2 - a1 + 15);\n  v9 = (unsigned __int64)&v12 & 0xFFFFFFFFFFFFFFF0LL;\n  mempcpy((unsigned __int64)&v12 & 0xFFFFFFFFFFFFFFF0LL, a1, a2 - a1);\n  while ( 1 )\n  {\n    if ( (unsigned __int64)v10 <= v9 )\n      return a2;\n    --v10;\n    --v5;\n    v11 = a2 - 4;\n    *((_DWORD *)a2 - 1) = *v10;\n    if ( !v5 && (unsigned __int64)v10 > v9 )\n      break;\nLABEL_13:\n    a2 = v11;\n  }\n  *((_DWORD *)a2 - 2) = v4;\n  v5 = (char)*v7;\n  v11 = a2 - 8;\n  if ( *v7 >= 0 && (_BYTE)v5 != 127 )\n  {\n    if ( (_BYTE)v5 )\n      ++v7;\n    else\n      v5 = (char)*(v7 - 1);\n    goto LABEL_13;\n  }\n  do\n  {\n    --v10;\n    v11 -= 4;\n    *(_DWORD *)v11 = *v10;\n  }\n  while ( (unsigned __int64)v10 > v9 );\n  return v11;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\npush    r15\npush    r14\nmov     r14d, ecx\npush    r13\npush    r12\npush    rbx\npush    rax\nmovsx   ebx, byte ptr [rdx]\nmov     rax, rdi\nlea     ecx, [rbx-1]\ncmp     cl, 7Dh\nja      loc_4018D0\nloc_40183f:\nlea     r13, [rdx+1]\nmov     rdx, rsi\nmov     r15, rsi\nsub     rdx, rdi\nmov     rsi, rdi\nlea     rax, [rdx+1Eh]\nand     rax, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rax\nlea     r12, [rsp+30h+var_21]\nand     r12, 0FFFFFFFFFFFFFFF0h\nmov     rdi, r12\ncall    mempcpy\nmov     rsi, r15\nloc_40186e:\ncmp     rax, r12\njbe     short loc_4018C8\nloc_401873:\nsub     rax, 4\nmov     r9d, [rax]\ndec     ebx\nlea     r8, [rsi-4]\nmov     [rsi-4], r9d\njnz     short loc_4018C3\nloc_401886:\ncmp     rax, r12\njbe     short loc_4018C3\nloc_40188b:\nmov     [rsi-8], r14d\nmovsx   ebx, byte ptr [r13+0]\nlea     r8, [rsi-8]\ntest    bl, bl\njs      short loc_4018A1\nloc_40189c:\ncmp     bl, 7Fh\njnz     short loc_4018B5\nloc_4018a1:\nsub     rax, 4\nmov     edx, [rax]\nsub     r8, 4\ncmp     rax, r12\nmov     [r8], edx\nja      short loc_4018A1\nloc_4018b3:\njmp     short loc_4018CD\nloc_4018b5:\ntest    bl, bl\njz      short loc_4018BE\nloc_4018b9:\ninc     r13\njmp     short loc_4018C3\nloc_4018be:\nmovsx   ebx, byte ptr [r13-1]\nloc_4018c3:\nmov     rsi, r8\njmp     short loc_40186E\nloc_4018c8:\nmov     rax, rsi\njmp     short loc_4018D0\nloc_4018cd:\nmov     rax, r8\nloc_4018d0:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn", "push    rbp\nmov     rbp, rsp\npush    r15\npush    r14\nmov     r14d, ecx\npush    r13\npush    r12\npush    rbx\npush    rax\nmovsx   ebx, byte ptr [rdx]\nmov     rax, rdi\nlea     ecx, [rbx-1]\ncmp     cl, 7Dh\nja      loc_4018D1\nloc_401840:\nlea     r13, [rdx+1]\nmov     rdx, rsi\nmov     r15, rsi\nsub     rdx, rdi\nmov     rsi, rdi\nlea     rax, [rdx+1Eh]\nand     rax, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rax\nlea     r12, [rsp+0Fh]\nand     r12, 0FFFFFFFFFFFFFFF0h\nmov     rdi, r12\ncall    mempcpy\nmov     rsi, r15\nloc_40186f:\ncmp     rax, r12\njbe     short loc_4018C9\nloc_401874:\nsub     rax, 4\nmov     r9d, [rax]\ndec     ebx\nlea     r8, [rsi-4]\nmov     [rsi-4], r9d\njnz     short loc_4018C4\nloc_401887:\ncmp     rax, r12\njbe     short loc_4018C4\nloc_40188c:\nmov     [rsi-8], r14d\nmovsx   ebx, byte ptr [r13+0]\nlea     r8, [rsi-8]\ntest    bl, bl\njs      short loc_4018A2\nloc_40189d:\ncmp     bl, 7Fh\njnz     short loc_4018B6\nloc_4018a2:\nsub     rax, 4\nmov     edx, [rax]\nsub     r8, 4\ncmp     rax, r12\nmov     [r8], edx\nja      short loc_4018A2\nloc_4018b4:\njmp     short loc_4018CE\nloc_4018b6:\ntest    bl, bl\njz      short loc_4018BF\nloc_4018ba:\ninc     r13\njmp     short loc_4018C4\nloc_4018bf:\nmovsx   ebx, byte ptr [r13-1]\nloc_4018c4:\nmov     rsi, r8\njmp     short loc_40186F\nloc_4018c9:\nmov     rax, rsi\njmp     short loc_4018D1\nloc_4018ce:\nmov     rax, r8\nloc_4018d1:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn"]}, {"ea": "00401ce0", "origin name": "deregister_tm_clones", "ea2": "00402420", "matched name": "deregister_tm_clones", "ratio": "1.000", "bb1": "4", "bb2": "4", "heuristic": "Mnemonics and names", "pseudo": ["signed __int64 deregister_tm_clones()\n{\n  signed __int64 result; // rax\n\n  result = &unk_6FCD57 - &edata;\n  if ( (unsigned __int64)(&unk_6FCD57 - &edata) > 0xE )\n    result = 0LL;\n  return result;\n}", "signed __int64 deregister_tm_clones()\n{\n  signed __int64 result; // rax\n\n  result = &unk_6F9D17 - &edata;\n  if ( (unsigned __int64)(&unk_6F9D17 - &edata) > 0xE )\n    result = 0LL;\n  return result;\n}"], "asm": ["mov     eax, offset unk_6FCD57\npush    rbp\nsub     rax, offset _edata\ncmp     rax, 0Eh\nmov     rbp, rsp\nja      short loc_401CF7\nloc_401cf5:\npop     rbp\nretn\nloc_401cf7:\nmov     eax, 0\ntest    rax, rax\njz      short loc_401CF5\nloc_401d01:\npop     rbp\nmov     edi, offset _edata\njmp     rax", "mov     eax, offset unk_6F9D17\npush    rbp\nsub     rax, offset _edata\ncmp     rax, 0Eh\nmov     rbp, rsp\nja      short loc_402437\nloc_402435:\npop     rbp\nretn\nloc_402437:\nmov     eax, 0\ntest    rax, rax\njz      short loc_402435\nloc_402441:\npop     rbp\nmov     edi, offset _edata\njmp     rax"]}, {"ea": "00401d10", "origin name": "register_tm_clones", "ea2": "00402450", "matched name": "register_tm_clones", "ratio": "1.000", "bb1": "4", "bb2": "4", "heuristic": "Mnemonics and names", "pseudo": ["__int64 register_tm_clones()\n{\n  return 0LL;\n}", "__int64 register_tm_clones()\n{\n  return 0LL;\n}"], "asm": ["mov     eax, offset _edata\npush    rbp\nsub     rax, offset _edata\nsar     rax, 3\nmov     rbp, rsp\nmov     rdx, rax\nshr     rdx, 3Fh\nadd     rax, rdx\nsar     rax, 1\njnz     short loc_401D34\nloc_401d32:\npop     rbp\nretn\nloc_401d34:\nmov     edx, 0\ntest    rdx, rdx\njz      short loc_401D32\nloc_401d3e:\npop     rbp\nmov     rsi, rax\nmov     edi, offset _edata\njmp     rdx", "mov     eax, offset _edata\npush    rbp\nsub     rax, offset _edata\nsar     rax, 3\nmov     rbp, rsp\nmov     rdx, rax\nshr     rdx, 3Fh\nadd     rax, rdx\nsar     rax, 1\njnz     short loc_402474\nloc_402472:\npop     rbp\nretn\nloc_402474:\nmov     edx, 0\ntest    rdx, rdx\njz      short loc_402472\nloc_40247e:\npop     rbp\nmov     rsi, rax\nmov     edi, offset _edata\njmp     rdx"]}, {"ea": "00401d50", "origin name": "__do_global_dtors_aux", "ea2": "00402490", "matched name": "__do_global_dtors_aux", "ratio": "1.000", "bb1": "5", "bb2": "5", "heuristic": "Mnemonics and names", "pseudo": ["__int64 (__fastcall *__fastcall _do_global_dtors_aux(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8))(_QWORD)\n{\n  double v8; // xmm4_8\n  double v9; // xmm5_8\n  __int64 (__fastcall *result)(_QWORD); // rax\n\n  if ( !completed_6470 )\n  {\n    deregister_tm_clones();\n    result = (__int64 (__fastcall *)(_QWORD))_deregister_frame_info;\n    if ( _deregister_frame_info )\n      result = (__int64 (__fastcall *)(_QWORD))_deregister_frame_info(\n                                                 &_EH_FRAME_BEGIN__,\n                                                 a1,\n                                                 a2,\n                                                 a3,\n                                                 a4,\n                                                 v8,\n                                                 v9,\n                                                 a7,\n                                                 a8);\n    completed_6470 = 1;\n  }\n  return result;\n}", "__int64 (__fastcall *_do_global_dtors_aux())(_QWORD)\n{\n  __int64 (__fastcall *result)(_QWORD); // rax\n\n  if ( !completed_6470 )\n  {\n    deregister_tm_clones();\n    result = _deregister_frame_info;\n    if ( _deregister_frame_info )\n      result = (__int64 (__fastcall *)(_QWORD))_deregister_frame_info(&_EH_FRAME_BEGIN__);\n    completed_6470 = 1;\n  }\n  return result;\n}"], "asm": ["cmp     cs:completed_6470, 0\njnz     short locret_401D7B\nloc_401d59:\npush    rbp\nmov     rbp, rsp\ncall    deregister_tm_clones\nmov     eax, offset __deregister_frame_info\ntest    rax, rax\njz      short loc_401D73\nloc_401d6c:\nmov     edi, offset __EH_FRAME_BEGIN__\ncall    rax ; __deregister_frame_info\nloc_401d73:\npop     rbp\nmov     cs:completed_6470, 1\nloc_401d7b:\nrep retn", "cmp     cs:completed_6470, 0\njnz     short locret_4024BB\nloc_402499:\npush    rbp\nmov     rbp, rsp\ncall    deregister_tm_clones\nmov     eax, offset __deregister_frame_info\ntest    rax, rax\njz      short loc_4024B3\nloc_4024ac:\nmov     edi, offset __EH_FRAME_BEGIN__\ncall    rax ; __deregister_frame_info\nloc_4024b3:\npop     rbp\nmov     cs:completed_6470, 1\nloc_4024bb:\nrep retn"]}], "partial matching": [{"ea": "004013be", "origin name": "_i18n_number_rewrite", "ea2": "004013bf", "matched name": "_i18n_number_rewrite", "ratio": "0.880", "bb1": "28", "bb2": "28", "heuristic": "Same constants", "pseudo": ["__int64 __fastcall i18n_number_rewrite(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)\n{\n  __int64 v11; // r14\n  __int64 v12; // rbx\n  _DWORD *v13; // r13\n  unsigned __int64 v14; // rsi\n  int v15; // er12\n  int v16; // eax\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  int v19; // er11\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  signed __int64 v22; // rax\n  int v23; // er11\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  signed __int64 v26; // rax\n  unsigned __int64 v27; // rdx\n  bool v28; // bl\n  int v29; // eax\n  bool v30; // bl\n  void *v31; // rsp\n  unsigned __int64 v32; // r12\n  unsigned __int64 v33; // rax\n  __int64 v34; // rdx\n  _BYTE *v35; // rax\n  _BYTE *v36; // r10\n  int v37; // ecx\n  const char *v38; // r11\n  unsigned __int64 v39; // r8\n  bool v40; // zf\n  __int16 *v41; // r8\n  signed __int64 v42; // rcx\n  __int16 *v43; // rdi\n  signed __int64 v44; // rcx\n  __int64 result; // rax\n  __int64 v46; // [rsp+8h] [rbp-88h]\n  __int64 v47; // [rsp+10h] [rbp-80h]\n  __int16 v48; // [rsp+20h] [rbp-70h]\n  __int16 v49; // [rsp+40h] [rbp-50h]\n\n  v11 = a3;\n  v12 = a2;\n  v13 = (_DWORD *)wctrans(\"to_outpunct\");\n  v14 = (unsigned __int64)v13;\n  v15 = towctrans(0x2Eu, v13);\n  v16 = towctrans(0x2Cu, v13);\n  if ( v13 )\n  {\n    LODWORD(v46) = v16;\n    v47 = 0LL;\n    v22 = wcrtomb(&v47, (char *)&v48, v15, v19, a4, a5, a6, a7, v20, v21, a10, a11);\n    if ( v22 == -1 )\n      v48 = 46;\n    else\n      *((_BYTE *)&v48 + v22) = 0;\n    v14 = (unsigned int)v46;\n    v47 = 0LL;\n    v26 = wcrtomb(&v47, (char *)&v49, v46, v23, a4, a5, a6, a7, v24, v25, a10, a11);\n    if ( v26 == -1 )\n      v49 = 44;\n    else\n      *((_BYTE *)&v49 + v26) = 0;\n  }\n  v27 = v12 - a1;\n  v28 = 1;\n  if ( v27 > 0x1000 )\n  {\n    v46 = v27;\n    _libc_alloca_cutoff(v27, v14, v27, v17, v18);\n    v27 = v46;\n    v28 = v29 != 0;\n  }\n  v30 = v28;\n  if ( v30 )\n  {\n    v31 = alloca(v27 + 15);\n    v32 = ((unsigned __int64)&v46 + 7) & 0xFFFFFFFFFFFFFFF0LL;\n  }\n  else\n  {\n    v46 = v27;\n    malloc(v27, v14, v27, v17, v18);\n    v32 = v33;\n    v27 = v46;\n    if ( !v33 )\n      return a1;\n  }\n  mempcpy(v32, a1, v27);\n  v34 = v11;\n  v36 = v35;\n  while ( (unsigned __int64)--v36 >= v32 )\n  {\n    v37 = (char)*v36;\n    if ( (unsigned __int8)(*v36 - 48) > 9u )\n    {\n      if ( v13 && (v37 & 0xFD) == 44 )\n      {\n        v40 = (_BYTE)v37 == 46;\n        v41 = &v48;\n        v42 = -1LL;\n        if ( !v40 )\n          v41 = &v49;\n        v43 = v41;\n        do\n        {\n          if ( !v42 )\n            break;\n          v40 = *(_BYTE *)v43 == 0;\n          v43 = (__int16 *)((char *)v43 + 1);\n          --v42;\n        }\n        while ( !v40 );\n        v44 = ~v42 - 1;\n        for ( v34 -= v44; --v44 != -1; *(_BYTE *)(v34 + v44) = *((_BYTE *)v41 + v44) )\n          ;\n      }\n      else\n      {\n        *(_BYTE *)(v34-- - 1) = v37;\n      }\n    }\n    else\n    {\n      v38 = *(const char **)(*(_QWORD *)__readfsqword(0xFFFFFFA8) + 8LL * (v37 - 7) + 64);\n      v39 = strlen(v38);\n      for ( v34 -= v39; --v39 != -1LL; *(_BYTE *)(v34 + v39) = v38[v39] )\n        ;\n    }\n  }\n  result = v34;\n  if ( !v30 )\n  {\n    v46 = v34;\n    free(v32);\n    result = v46;\n  }\n  return result;\n}", "__int64 __fastcall i18n_number_rewrite(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v3; // r14\n  __int64 v4; // r13\n  unsigned int v5; // er12\n  unsigned int v6; // eax\n  __int64 v7; // rax\n  __int64 v8; // rax\n  __int64 v9; // rdx\n  bool v10; // bl\n  int v11; // eax\n  bool v12; // bl\n  void *v13; // rsp\n  _BYTE *v14; // r12\n  _BYTE *v15; // rax\n  __int64 v16; // rdx\n  _BYTE *v17; // rax\n  _BYTE *v18; // r10\n  int v19; // ecx\n  const char *v20; // r11\n  unsigned __int64 v21; // r8\n  bool v22; // zf\n  __int64 *v23; // r8\n  signed __int64 v24; // rcx\n  __int64 *v25; // rdi\n  signed __int64 v26; // rcx\n  __int64 result; // rax\n  unsigned int v28; // [rsp-90h] [rbp-90h]\n  __int64 v29; // [rsp-90h] [rbp-90h]\n  __int64 v30; // [rsp-90h] [rbp-90h]\n  __int64 v31; // [rsp-90h] [rbp-90h]\n  __int64 v32; // [rsp-88h] [rbp-88h]\n  __int64 v33; // [rsp-78h] [rbp-78h]\n  __int64 v34; // [rsp-58h] [rbp-58h]\n  __int64 v35; // [rsp-8h] [rbp-8h]\n\n  v3 = a3;\n  v4 = wctrans(\"to_outpunct\");\n  v5 = towctrans(46LL, v4);\n  v6 = towctrans(44LL, v4);\n  if ( v4 )\n  {\n    v28 = v6;\n    v32 = 0LL;\n    wcrtomb(&v33, v5, &v32);\n    if ( v7 == -1 )\n      LOWORD(v33) = 46;\n    else\n      *((_BYTE *)&v35 + v7 - 112) = 0;\n    v32 = 0LL;\n    wcrtomb(&v34, v28, &v32);\n    if ( v8 == -1 )\n      LOWORD(v34) = 44;\n    else\n      *((_BYTE *)&v35 + v8 - 80) = 0;\n  }\n  v9 = a2 - a1;\n  v10 = 1;\n  if ( (unsigned __int64)(a2 - a1) > 0x1000 )\n  {\n    v29 = a2 - a1;\n    _libc_alloca_cutoff(v9);\n    v9 = a2 - a1;\n    v10 = v11 != 0;\n  }\n  v12 = v10;\n  if ( v12 )\n  {\n    v13 = alloca(v9 + 15);\n    v14 = (_BYTE *)(((unsigned __int64)&v29 + 7) & 0xFFFFFFFFFFFFFFF0LL);\n  }\n  else\n  {\n    v30 = v9;\n    malloc(v9);\n    v14 = v15;\n    v9 = v30;\n    if ( !v15 )\n      return a1;\n  }\n  mempcpy(v14, a1, v9);\n  v16 = v3;\n  v18 = v17;\n  while ( --v18 >= v14 )\n  {\n    v19 = (char)*v18;\n    if ( (unsigned __int8)(*v18 - 48) > 9u )\n    {\n      if ( v4 && (v19 & 0xFD) == 44 )\n      {\n        v22 = (_BYTE)v19 == 46;\n        v23 = &v33;\n        v24 = -1LL;\n        if ( !v22 )\n          v23 = &v34;\n        v25 = v23;\n        do\n        {\n          if ( !v24 )\n            break;\n          v22 = *(_BYTE *)v25 == 0;\n          v25 = (__int64 *)((char *)v25 + 1);\n          --v24;\n        }\n        while ( !v22 );\n        v26 = ~v24 - 1;\n        for ( v16 -= v26; --v26 != -1; *(_BYTE *)(v16 + v26) = *((_BYTE *)v23 + v26) )\n          ;\n      }\n      else\n      {\n        *(_BYTE *)(v16-- - 1) = v19;\n      }\n    }\n    else\n    {\n      v20 = *(const char **)(*(_QWORD *)__readfsqword(0xFFFFFFA8) + 8LL * (v19 - 7) + 64);\n      v21 = strlen(v20);\n      for ( v16 -= v21; --v21 != -1LL; *(_BYTE *)(v16 + v21) = v20[v21] )\n        ;\n    }\n  }\n  result = v16;\n  if ( !v12 )\n  {\n    v31 = v16;\n    free(v14);\n    result = v31;\n  }\n  return result;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\npush    r15\nmov     r15, rdi\nmov     edi, offset aToOutpunct; \"to_outpunct\"\npush    r14\nmov     r14, rdx\npush    r13\npush    r12\npush    rbx\nmov     rbx, rsi\nsub     rsp, 68h\ncall    wctrans\nmov     edi, 2Eh\nmov     r13, rax\nmov     rsi, rax\ncall    towctrans\nmov     rsi, r13\nmov     edi, 2Ch\nmov     r12d, eax\ncall    towctrans\ntest    r13, r13\njz      short loc_401468\nloc_401407:\nlea     rdx, [rbp+var_80]\nlea     rdi, [rbp+var_70]\nmov     esi, r12d\nmov     dword ptr [rbp+var_88], eax\nmov     [rbp+var_80], 0\ncall    wcrtomb\ncmp     rax, 0FFFFFFFFFFFFFFFFh\nmov     ecx, dword ptr [rbp+var_88]\njnz     short loc_401439\nloc_401431:\nmov     [rbp+var_70], 2Eh\njmp     short loc_40143E\nloc_401439:\nmov     byte ptr [rbp+rax+var_70], 0\nloc_40143e:\nlea     rdx, [rbp+var_80]\nlea     rdi, [rbp+var_50]\nmov     esi, ecx\nmov     [rbp+var_80], 0\ncall    wcrtomb\ncmp     rax, 0FFFFFFFFFFFFFFFFh\njnz     short loc_401463\nloc_40145b:\nmov     [rbp+var_50], 2Ch\njmp     short loc_401468\nloc_401463:\nmov     byte ptr [rbp+rax+var_50], 0\nloc_401468:\nsub     rbx, r15\nmov     rdx, rbx\nmov     ebx, 1\ncmp     rdx, 1000h\njbe     short loc_401499\nloc_40147c:\nmov     rdi, rdx\nmov     [rbp+var_88], rdx\nxor     ebx, ebx\ncall    __libc_alloca_cutoff\nmov     rdx, [rbp+var_88]\ntest    eax, eax\nsetnz   bl\nloc_401499:\nand     bl, 1\njz      short loc_4014B4\nloc_40149e:\nlea     rax, [rdx+1Eh]\nand     rax, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rax\nlea     r12, [rsp+90h+var_88+7]\nand     r12, 0FFFFFFFFFFFFFFF0h\njmp     short loc_4014D6\nloc_4014b4:\nmov     rdi, rdx\nmov     [rbp+var_88], rdx\ncall    malloc\ntest    rax, rax\nmov     r12, rax\nmov     rdx, [rbp+var_88]\njz      loc_4015B6\nloc_4014d6:\nmov     rsi, r15\nmov     rdi, r12\nlea     r15, [rbp+var_50]\ncall    mempcpy\nmov     rdx, r14\nlea     r14, [rbp+var_70]\nmov     r10, rax\nor      rsi, 0FFFFFFFFFFFFFFFFh\nxor     eax, eax\nloc_4014f5:\ndec     r10\ncmp     r10, r12\njb      loc_401597\nloc_401501:\nmovsx   ecx, byte ptr [r10]\nlea     edi, [rcx-30h]\ncmp     dil, 9\nja      short loc_40154C\nloc_40150e:\nmov     rdi, 0FFFFFFFFFFFFFFA8h\nsub     ecx, 7\nmovsxd  rcx, ecx\nmov     rdi, fs:[rdi]\nmov     rdi, [rdi]\nmov     r11, [rdi+rcx*8+40h]\nmov     rcx, rsi\nmov     rdi, r11\nrepne scasb\nnot     rcx\nlea     r8, [rcx-1]\nsub     rdx, r8\nloc_401539:\ndec     r8\ncmp     r8, 0FFFFFFFFFFFFFFFFh\njz      short loc_4014F5\nloc_401542:\nmov     r9b, [r11+r8]\nmov     [rdx+r8], r9b\njmp     short loc_401539\nloc_40154c:\ntest    r13, r13\njz      short loc_40155D\nloc_401551:\nmov     dil, cl\nand     edi, 0FFFFFFFDh\ncmp     dil, 2Ch\njz      short loc_401565\nloc_40155d:\nmov     [rdx-1], cl\ndec     rdx\njmp     short loc_4014F5\nloc_401565:\ncmp     cl, 2Eh\nmov     r8, r14\nmov     rcx, rsi\ncmovnz  r8, r15\nmov     rdi, r8\nrepne scasb\nnot     rcx\ndec     rcx\nsub     rdx, rcx\nloc_401580:\ndec     rcx\ncmp     rcx, 0FFFFFFFFFFFFFFFFh\njz      loc_4014F5\nloc_40158d:\nmov     dil, [r8+rcx]\nmov     [rdx+rcx], dil\njmp     short loc_401580\nloc_401597:\ntest    bl, bl\nmov     rax, rdx\njnz     short loc_4015B9\nloc_40159e:\nmov     rdi, r12\nmov     [rbp+var_88], rdx\ncall    free\nmov     rax, [rbp+var_88]\njmp     short loc_4015B9\nloc_4015b6:\nmov     rax, r15\nloc_4015b9:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn", "push    rbp\nmov     rbp, rsp\npush    r15\nmov     r15, rdi\nmov     edi, offset aToOutpunct; \"to_outpunct\"\npush    r14\nmov     r14, rdx\npush    r13\npush    r12\npush    rbx\nmov     rbx, rsi\nsub     rsp, 68h\ncall    wctrans\nmov     edi, 2Eh\nmov     r13, rax\nmov     rsi, rax\ncall    towctrans\nmov     rsi, r13\nmov     edi, 2Ch\nmov     r12d, eax\ncall    towctrans\ntest    r13, r13\njz      short loc_401469\nloc_401408:\nlea     rdx, [rbp-80h]\nlea     rdi, [rbp-70h]\nmov     esi, r12d\nmov     [rbp-88h], eax\nmov     qword ptr [rbp-80h], 0\ncall    wcrtomb\ncmp     rax, 0FFFFFFFFFFFFFFFFh\nmov     ecx, [rbp-88h]\njnz     short loc_40143A\nloc_401432:\nmov     word ptr [rbp-70h], 2Eh\njmp     short loc_40143F\nloc_40143a:\nmov     byte ptr [rbp+rax-70h], 0\nloc_40143f:\nlea     rdx, [rbp-80h]\nlea     rdi, [rbp-50h]\nmov     esi, ecx\nmov     qword ptr [rbp-80h], 0\ncall    wcrtomb\ncmp     rax, 0FFFFFFFFFFFFFFFFh\njnz     short loc_401464\nloc_40145c:\nmov     word ptr [rbp-50h], 2Ch\njmp     short loc_401469\nloc_401464:\nmov     byte ptr [rbp+rax-50h], 0\nloc_401469:\nsub     rbx, r15\nmov     rdx, rbx\nmov     ebx, 1\ncmp     rdx, 1000h\njbe     short loc_40149A\nloc_40147d:\nmov     rdi, rdx\nmov     [rbp-88h], rdx\nxor     ebx, ebx\ncall    __libc_alloca_cutoff\nmov     rdx, [rbp-88h]\ntest    eax, eax\nsetnz   bl\nloc_40149a:\nand     bl, 1\njz      short loc_4014B5\nloc_40149f:\nlea     rax, [rdx+1Eh]\nand     rax, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rax\nlea     r12, [rsp+0Fh]\nand     r12, 0FFFFFFFFFFFFFFF0h\njmp     short loc_4014D7\nloc_4014b5:\nmov     rdi, rdx\nmov     [rbp-88h], rdx\ncall    malloc\ntest    rax, rax\nmov     r12, rax\nmov     rdx, [rbp-88h]\njz      loc_4015B7\nloc_4014d7:\nmov     rsi, r15\nmov     rdi, r12\nlea     r15, [rbp-50h]\ncall    mempcpy\nmov     rdx, r14\nlea     r14, [rbp-70h]\nmov     r10, rax\nor      rsi, 0FFFFFFFFFFFFFFFFh\nxor     eax, eax\nloc_4014f6:\ndec     r10\ncmp     r10, r12\njb      loc_401598\nloc_401502:\nmovsx   ecx, byte ptr [r10]\nlea     edi, [rcx-30h]\ncmp     dil, 9\nja      short loc_40154D\nloc_40150f:\nmov     rdi, 0FFFFFFFFFFFFFFA8h\nsub     ecx, 7\nmovsxd  rcx, ecx\nmov     rdi, fs:[rdi]\nmov     rdi, [rdi]\nmov     r11, [rdi+rcx*8+40h]\nmov     rcx, rsi\nmov     rdi, r11\nrepne scasb\nnot     rcx\nlea     r8, [rcx-1]\nsub     rdx, r8\nloc_40153a:\ndec     r8\ncmp     r8, 0FFFFFFFFFFFFFFFFh\njz      short loc_4014F6\nloc_401543:\nmov     r9b, [r11+r8]\nmov     [rdx+r8], r9b\njmp     short loc_40153A\nloc_40154d:\ntest    r13, r13\njz      short loc_40155E\nloc_401552:\nmov     dil, cl\nand     edi, 0FFFFFFFDh\ncmp     dil, 2Ch\njz      short loc_401566\nloc_40155e:\nmov     [rdx-1], cl\ndec     rdx\njmp     short loc_4014F6\nloc_401566:\ncmp     cl, 2Eh\nmov     r8, r14\nmov     rcx, rsi\ncmovnz  r8, r15\nmov     rdi, r8\nrepne scasb\nnot     rcx\ndec     rcx\nsub     rdx, rcx\nloc_401581:\ndec     rcx\ncmp     rcx, 0FFFFFFFFFFFFFFFFh\njz      loc_4014F6\nloc_40158e:\nmov     dil, [r8+rcx]\nmov     [rdx+rcx], dil\njmp     short loc_401581\nloc_401598:\ntest    bl, bl\nmov     rax, rdx\njnz     short loc_4015BA\nloc_40159f:\nmov     rdi, r12; void *\nmov     [rbp-88h], rdx\ncall    free\nmov     rax, [rbp-88h]\njmp     short loc_4015BA\nloc_4015b7:\nmov     rax, r15\nloc_4015ba:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn"]}, {"ea": "004015c8", "origin name": "_i18n_number_rewrite_0", "ea2": "004015c9", "matched name": "_i18n_number_rewrite_0", "ratio": "0.880", "bb1": "28", "bb2": "28", "heuristic": "Same constants", "pseudo": ["__int64 __fastcall i18n_number_rewrite_0(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)\n{\n  __int64 v11; // r14\n  __int64 v12; // rbx\n  _DWORD *v13; // r13\n  unsigned __int64 v14; // rsi\n  int v15; // er12\n  int v16; // eax\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  int v19; // er11\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  signed __int64 v22; // rax\n  int v23; // er11\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  signed __int64 v26; // rax\n  unsigned __int64 v27; // rdx\n  bool v28; // bl\n  int v29; // eax\n  bool v30; // bl\n  void *v31; // rsp\n  unsigned __int64 v32; // r12\n  unsigned __int64 v33; // rax\n  __int64 v34; // rdx\n  _BYTE *v35; // rax\n  _BYTE *v36; // r10\n  int v37; // ecx\n  const char *v38; // r11\n  unsigned __int64 v39; // r8\n  bool v40; // zf\n  __int16 *v41; // r8\n  signed __int64 v42; // rcx\n  __int16 *v43; // rdi\n  signed __int64 v44; // rcx\n  __int64 result; // rax\n  __int64 v46; // [rsp+8h] [rbp-88h]\n  __int64 v47; // [rsp+10h] [rbp-80h]\n  __int16 v48; // [rsp+20h] [rbp-70h]\n  __int16 v49; // [rsp+40h] [rbp-50h]\n\n  v11 = a3;\n  v12 = a2;\n  v13 = (_DWORD *)wctrans(\"to_outpunct\");\n  v14 = (unsigned __int64)v13;\n  v15 = towctrans(0x2Eu, v13);\n  v16 = towctrans(0x2Cu, v13);\n  if ( v13 )\n  {\n    LODWORD(v46) = v16;\n    v47 = 0LL;\n    v22 = wcrtomb(&v47, (char *)&v48, v15, v19, a4, a5, a6, a7, v20, v21, a10, a11);\n    if ( v22 == -1 )\n      v48 = 46;\n    else\n      *((_BYTE *)&v48 + v22) = 0;\n    v14 = (unsigned int)v46;\n    v47 = 0LL;\n    v26 = wcrtomb(&v47, (char *)&v49, v46, v23, a4, a5, a6, a7, v24, v25, a10, a11);\n    if ( v26 == -1 )\n      v49 = 44;\n    else\n      *((_BYTE *)&v49 + v26) = 0;\n  }\n  v27 = v12 - a1;\n  v28 = 1;\n  if ( v27 > 0x1000 )\n  {\n    v46 = v27;\n    _libc_alloca_cutoff(v27, v14, v27, v17, v18);\n    v27 = v46;\n    v28 = v29 != 0;\n  }\n  v30 = v28;\n  if ( v30 )\n  {\n    v31 = alloca(v27 + 15);\n    v32 = ((unsigned __int64)&v46 + 7) & 0xFFFFFFFFFFFFFFF0LL;\n  }\n  else\n  {\n    v46 = v27;\n    malloc(v27, v14, v27, v17, v18);\n    v32 = v33;\n    v27 = v46;\n    if ( !v33 )\n      return a1;\n  }\n  mempcpy(v32, a1, v27);\n  v34 = v11;\n  v36 = v35;\n  while ( (unsigned __int64)--v36 >= v32 )\n  {\n    v37 = (char)*v36;\n    if ( (unsigned __int8)(*v36 - 48) > 9u )\n    {\n      if ( v13 && (v37 & 0xFD) == 44 )\n      {\n        v40 = (_BYTE)v37 == 46;\n        v41 = &v48;\n        v42 = -1LL;\n        if ( !v40 )\n          v41 = &v49;\n        v43 = v41;\n        do\n        {\n          if ( !v42 )\n            break;\n          v40 = *(_BYTE *)v43 == 0;\n          v43 = (__int16 *)((char *)v43 + 1);\n          --v42;\n        }\n        while ( !v40 );\n        v44 = ~v42 - 1;\n        for ( v34 -= v44; --v44 != -1; *(_BYTE *)(v34 + v44) = *((_BYTE *)v41 + v44) )\n          ;\n      }\n      else\n      {\n        *(_BYTE *)(v34-- - 1) = v37;\n      }\n    }\n    else\n    {\n      v38 = *(const char **)(*(_QWORD *)__readfsqword(0xFFFFFFA8) + 8LL * (v37 - 7) + 64);\n      v39 = strlen(v38);\n      for ( v34 -= v39; --v39 != -1LL; *(_BYTE *)(v34 + v39) = v38[v39] )\n        ;\n    }\n  }\n  result = v34;\n  if ( !v30 )\n  {\n    v46 = v34;\n    free(v32);\n    result = v46;\n  }\n  return result;\n}", "__int64 __fastcall i18n_number_rewrite_0(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v3; // r14\n  __int64 v4; // r13\n  unsigned int v5; // er12\n  unsigned int v6; // eax\n  __int64 v7; // rax\n  __int64 v8; // rax\n  __int64 v9; // rdx\n  _BOOL8 v10; // rbx\n  int v11; // eax\n  bool v12; // bl\n  void *v13; // rsp\n  _BYTE *v14; // r12\n  _BYTE *v15; // rax\n  __int64 v16; // rdx\n  _BYTE *v17; // rax\n  _BYTE *v18; // r10\n  int v19; // ecx\n  const char *v20; // r11\n  unsigned __int64 v21; // r8\n  bool v22; // zf\n  __int64 *v23; // r8\n  signed __int64 v24; // rcx\n  __int64 *v25; // rdi\n  signed __int64 v26; // rcx\n  __int64 result; // rax\n  unsigned int v28; // [rsp-90h] [rbp-90h]\n  __int64 v29; // [rsp-90h] [rbp-90h]\n  __int64 v30; // [rsp-90h] [rbp-90h]\n  __int64 v31; // [rsp-90h] [rbp-90h]\n  __int64 v32; // [rsp-88h] [rbp-88h]\n  __int64 v33; // [rsp-78h] [rbp-78h]\n  __int64 v34; // [rsp-58h] [rbp-58h]\n  __int64 v35; // [rsp-8h] [rbp-8h]\n\n  v3 = a3;\n  v4 = wctrans(\"to_outpunct\");\n  v5 = towctrans(46LL, v4);\n  v6 = towctrans(44LL, v4);\n  if ( v4 )\n  {\n    v28 = v6;\n    v32 = 0LL;\n    wcrtomb(&v33, v5, &v32);\n    if ( v7 == -1 )\n      LOWORD(v33) = 46;\n    else\n      *((_BYTE *)&v35 + v7 - 112) = 0;\n    v32 = 0LL;\n    wcrtomb(&v34, v28, &v32);\n    if ( v8 == -1 )\n      LOWORD(v34) = 44;\n    else\n      *((_BYTE *)&v35 + v8 - 80) = 0;\n  }\n  v9 = a2 - a1;\n  LOBYTE(v10) = 1;\n  if ( (unsigned __int64)(a2 - a1) > 0x1000 )\n  {\n    v29 = a2 - a1;\n    _libc_alloca_cutoff(v9);\n    v9 = a2 - a1;\n    v10 = v11 != 0;\n  }\n  v12 = v10;\n  if ( v12 )\n  {\n    v13 = alloca(v9 + 15);\n    v14 = (_BYTE *)(((unsigned __int64)&v29 + 7) & 0xFFFFFFFFFFFFFFF0LL);\n  }\n  else\n  {\n    v30 = v9;\n    malloc(v9);\n    v14 = v15;\n    v9 = v30;\n    if ( !v15 )\n      return a1;\n  }\n  mempcpy(v14, a1, v9);\n  v16 = v3;\n  v18 = v17;\n  while ( --v18 >= v14 )\n  {\n    v19 = (char)*v18;\n    if ( (unsigned __int8)(*v18 - 48) > 9u )\n    {\n      if ( v4 && (v19 & 0xFD) == 44 )\n      {\n        v22 = (_BYTE)v19 == 46;\n        v23 = &v33;\n        v24 = -1LL;\n        if ( !v22 )\n          v23 = &v34;\n        v25 = v23;\n        do\n        {\n          if ( !v24 )\n            break;\n          v22 = *(_BYTE *)v25 == 0;\n          v25 = (__int64 *)((char *)v25 + 1);\n          --v24;\n        }\n        while ( !v22 );\n        v26 = ~v24 - 1;\n        for ( v16 -= v26; --v26 != -1; *(_BYTE *)(v16 + v26) = *((_BYTE *)v23 + v26) )\n          ;\n      }\n      else\n      {\n        *(_BYTE *)(v16-- - 1) = v19;\n      }\n    }\n    else\n    {\n      v20 = *(const char **)(*(_QWORD *)__readfsqword(0xFFFFFFA8) + 8LL * (v19 - 7) + 64);\n      v21 = strlen(v20);\n      for ( v16 -= v21; --v21 != -1LL; *(_BYTE *)(v16 + v21) = v20[v21] )\n        ;\n    }\n  }\n  result = v16;\n  if ( !v12 )\n  {\n    v31 = v16;\n    free(v14);\n    result = v31;\n  }\n  return result;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\npush    r15\nmov     r15, rdi\nmov     edi, offset aToOutpunct; \"to_outpunct\"\npush    r14\nmov     r14, rdx\npush    r13\npush    r12\npush    rbx\nmov     rbx, rsi\nsub     rsp, 68h\ncall    wctrans\nmov     edi, 2Eh\nmov     r13, rax\nmov     rsi, rax\ncall    towctrans\nmov     rsi, r13\nmov     edi, 2Ch\nmov     r12d, eax\ncall    towctrans\ntest    r13, r13\njz      short loc_401672\nloc_401611:\nlea     rdx, [rbp+var_80]\nlea     rdi, [rbp+var_70]\nmov     esi, r12d\nmov     dword ptr [rbp+var_88], eax\nmov     [rbp+var_80], 0\ncall    wcrtomb\ncmp     rax, 0FFFFFFFFFFFFFFFFh\nmov     ecx, dword ptr [rbp+var_88]\njnz     short loc_401643\nloc_40163b:\nmov     [rbp+var_70], 2Eh\njmp     short loc_401648\nloc_401643:\nmov     byte ptr [rbp+rax+var_70], 0\nloc_401648:\nlea     rdx, [rbp+var_80]\nlea     rdi, [rbp+var_50]\nmov     esi, ecx\nmov     [rbp+var_80], 0\ncall    wcrtomb\ncmp     rax, 0FFFFFFFFFFFFFFFFh\njnz     short loc_40166D\nloc_401665:\nmov     [rbp+var_50], 2Ch\njmp     short loc_401672\nloc_40166d:\nmov     byte ptr [rbp+rax+var_50], 0\nloc_401672:\nsub     rbx, r15\nmov     rdx, rbx\nmov     ebx, 1\ncmp     rdx, 1000h\njbe     short loc_4016A3\nloc_401686:\nmov     rdi, rdx\nmov     [rbp+var_88], rdx\nxor     ebx, ebx\ncall    __libc_alloca_cutoff\nmov     rdx, [rbp+var_88]\ntest    eax, eax\nsetnz   bl\nloc_4016a3:\nand     bl, 1\njz      short loc_4016BE\nloc_4016a8:\nlea     rax, [rdx+1Eh]\nand     rax, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rax\nlea     r12, [rsp+90h+var_88+7]\nand     r12, 0FFFFFFFFFFFFFFF0h\njmp     short loc_4016E0\nloc_4016be:\nmov     rdi, rdx\nmov     [rbp+var_88], rdx\ncall    malloc\ntest    rax, rax\nmov     r12, rax\nmov     rdx, [rbp+var_88]\njz      loc_4017C0\nloc_4016e0:\nmov     rsi, r15\nmov     rdi, r12\nlea     r15, [rbp+var_50]\ncall    mempcpy\nmov     rdx, r14\nlea     r14, [rbp+var_70]\nmov     r10, rax\nor      rsi, 0FFFFFFFFFFFFFFFFh\nxor     eax, eax\nloc_4016ff:\ndec     r10\ncmp     r10, r12\njb      loc_4017A1\nloc_40170b:\nmovsx   ecx, byte ptr [r10]\nlea     edi, [rcx-30h]\ncmp     dil, 9\nja      short loc_401756\nloc_401718:\nmov     rdi, 0FFFFFFFFFFFFFFA8h\nsub     ecx, 7\nmovsxd  rcx, ecx\nmov     rdi, fs:[rdi]\nmov     rdi, [rdi]\nmov     r11, [rdi+rcx*8+40h]\nmov     rcx, rsi\nmov     rdi, r11\nrepne scasb\nnot     rcx\nlea     r8, [rcx-1]\nsub     rdx, r8\nloc_401743:\ndec     r8\ncmp     r8, 0FFFFFFFFFFFFFFFFh\njz      short loc_4016FF\nloc_40174c:\nmov     r9b, [r11+r8]\nmov     [rdx+r8], r9b\njmp     short loc_401743\nloc_401756:\ntest    r13, r13\njz      short loc_401767\nloc_40175b:\nmov     dil, cl\nand     edi, 0FFFFFFFDh\ncmp     dil, 2Ch\njz      short loc_40176F\nloc_401767:\nmov     [rdx-1], cl\ndec     rdx\njmp     short loc_4016FF\nloc_40176f:\ncmp     cl, 2Eh\nmov     r8, r14\nmov     rcx, rsi\ncmovnz  r8, r15\nmov     rdi, r8\nrepne scasb\nnot     rcx\ndec     rcx\nsub     rdx, rcx\nloc_40178a:\ndec     rcx\ncmp     rcx, 0FFFFFFFFFFFFFFFFh\njz      loc_4016FF\nloc_401797:\nmov     dil, [r8+rcx]\nmov     [rdx+rcx], dil\njmp     short loc_40178A\nloc_4017a1:\ntest    bl, bl\nmov     rax, rdx\njnz     short loc_4017C3\nloc_4017a8:\nmov     rdi, r12\nmov     [rbp+var_88], rdx\ncall    free\nmov     rax, [rbp+var_88]\njmp     short loc_4017C3\nloc_4017c0:\nmov     rax, r15\nloc_4017c3:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn", "push    rbp\nmov     rbp, rsp\npush    r15\nmov     r15, rdi\nmov     edi, offset aToOutpunct; \"to_outpunct\"\npush    r14\nmov     r14, rdx\npush    r13\npush    r12\npush    rbx\nmov     rbx, rsi\nsub     rsp, 68h\ncall    wctrans\nmov     edi, 2Eh\nmov     r13, rax\nmov     rsi, rax\ncall    towctrans\nmov     rsi, r13\nmov     edi, 2Ch\nmov     r12d, eax\ncall    towctrans\ntest    r13, r13\njz      short loc_401673\nloc_401612:\nlea     rdx, [rbp-80h]\nlea     rdi, [rbp-70h]\nmov     esi, r12d\nmov     [rbp-88h], eax\nmov     qword ptr [rbp-80h], 0\ncall    wcrtomb\ncmp     rax, 0FFFFFFFFFFFFFFFFh\nmov     ecx, [rbp-88h]\njnz     short loc_401644\nloc_40163c:\nmov     word ptr [rbp-70h], 2Eh\njmp     short loc_401649\nloc_401644:\nmov     byte ptr [rbp+rax-70h], 0\nloc_401649:\nlea     rdx, [rbp-80h]\nlea     rdi, [rbp-50h]\nmov     esi, ecx\nmov     qword ptr [rbp-80h], 0\ncall    wcrtomb\ncmp     rax, 0FFFFFFFFFFFFFFFFh\njnz     short loc_40166E\nloc_401666:\nmov     word ptr [rbp-50h], 2Ch\njmp     short loc_401673\nloc_40166e:\nmov     byte ptr [rbp+rax-50h], 0\nloc_401673:\nsub     rbx, r15\nmov     rdx, rbx\nmov     ebx, 1\ncmp     rdx, 1000h\njbe     short loc_4016A4\nloc_401687:\nmov     rdi, rdx\nmov     [rbp-88h], rdx\nxor     ebx, ebx\ncall    __libc_alloca_cutoff\nmov     rdx, [rbp-88h]\ntest    eax, eax\nsetnz   bl\nloc_4016a4:\nand     bl, 1\njz      short loc_4016BF\nloc_4016a9:\nlea     rax, [rdx+1Eh]\nand     rax, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rax\nlea     r12, [rsp+0Fh]\nand     r12, 0FFFFFFFFFFFFFFF0h\njmp     short loc_4016E1\nloc_4016bf:\nmov     rdi, rdx\nmov     [rbp-88h], rdx\ncall    malloc\ntest    rax, rax\nmov     r12, rax\nmov     rdx, [rbp-88h]\njz      loc_4017C1\nloc_4016e1:\nmov     rsi, r15\nmov     rdi, r12\nlea     r15, [rbp-50h]\ncall    mempcpy\nmov     rdx, r14\nlea     r14, [rbp-70h]\nmov     r10, rax\nor      rsi, 0FFFFFFFFFFFFFFFFh\nxor     eax, eax\nloc_401700:\ndec     r10\ncmp     r10, r12\njb      loc_4017A2\nloc_40170c:\nmovsx   ecx, byte ptr [r10]\nlea     edi, [rcx-30h]\ncmp     dil, 9\nja      short loc_401757\nloc_401719:\nmov     rdi, 0FFFFFFFFFFFFFFA8h\nsub     ecx, 7\nmovsxd  rcx, ecx\nmov     rdi, fs:[rdi]\nmov     rdi, [rdi]\nmov     r11, [rdi+rcx*8+40h]\nmov     rcx, rsi\nmov     rdi, r11\nrepne scasb\nnot     rcx\nlea     r8, [rcx-1]\nsub     rdx, r8\nloc_401744:\ndec     r8\ncmp     r8, 0FFFFFFFFFFFFFFFFh\njz      short loc_401700\nloc_40174d:\nmov     r9b, [r11+r8]\nmov     [rdx+r8], r9b\njmp     short loc_401744\nloc_401757:\ntest    r13, r13\njz      short loc_401768\nloc_40175c:\nmov     dil, cl\nand     edi, 0FFFFFFFDh\ncmp     dil, 2Ch\njz      short loc_401770\nloc_401768:\nmov     [rdx-1], cl\ndec     rdx\njmp     short loc_401700\nloc_401770:\ncmp     cl, 2Eh\nmov     r8, r14\nmov     rcx, rsi\ncmovnz  r8, r15\nmov     rdi, r8\nrepne scasb\nnot     rcx\ndec     rcx\nsub     rdx, rcx\nloc_40178b:\ndec     rcx\ncmp     rcx, 0FFFFFFFFFFFFFFFFh\njz      loc_401700\nloc_401798:\nmov     dil, [r8+rcx]\nmov     [rdx+rcx], dil\njmp     short loc_40178B\nloc_4017a2:\ntest    bl, bl\nmov     rax, rdx\njnz     short loc_4017C4\nloc_4017a9:\nmov     rdi, r12; void *\nmov     [rbp-88h], rdx\ncall    free\nmov     rax, [rbp-88h]\njmp     short loc_4017C4\nloc_4017c1:\nmov     rax, r15\nloc_4017c4:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn"]}, {"ea": "004018df", "origin name": "_i18n_number_rewrite_1", "ea2": "004018e0", "matched name": "_i18n_number_rewrite_1", "ratio": "0.920", "bb1": "18", "bb2": "18", "heuristic": "Same constants", "pseudo": ["_DWORD *__fastcall i18n_number_rewrite_1(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)\n{\n  __int64 v11; // r13\n  bool v12; // bl\n  _DWORD *v13; // r14\n  __int64 v14; // rdx\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  int v17; // eax\n  bool v18; // bl\n  void *v19; // rsp\n  unsigned __int64 v20; // r15\n  unsigned __int64 v21; // rax\n  int *v22; // rax\n  int *v23; // rcx\n  _QWORD *v24; // rsi\n  _DWORD *i; // rdx\n  _DWORD *result; // rax\n  int v27; // er8\n  int v28; // eax\n  int v29; // [rsp+0h] [rbp-40h]\n  int v30; // [rsp+4h] [rbp-3Ch]\n  _DWORD *v31; // [rsp+8h] [rbp-38h]\n\n  v11 = a2 - a1;\n  v12 = 1;\n  v31 = (_DWORD *)a3;\n  v13 = (_DWORD *)wctrans(\"to_outpunct\");\n  v30 = towctrans(0x2Eu, v13);\n  v29 = towctrans(0x2Cu, v13);\n  if ( (unsigned __int64)(a2 - a1) > 0x1000 )\n  {\n    _libc_alloca_cutoff(v11, v13, v14, v15, v16);\n    v12 = v17 != 0;\n  }\n  v18 = v12;\n  if ( v18 )\n  {\n    v19 = alloca(v11 + 15);\n    v20 = ((unsigned __int64)&v31 + 7) & 0xFFFFFFFFFFFFFFF0LL;\n  }\n  else\n  {\n    malloc(v11, v13, v14, v15, v16);\n    v20 = v21;\n    if ( !v21 )\n      return (_DWORD *)a1;\n  }\n  mempcpy(v20, a1, v11);\n  v23 = v22;\n  v24 = (_QWORD *)__readfsqword(0xFFFFFFA8);\n  for ( i = v31 - 1; ; --i )\n  {\n    --v23;\n    result = i + 1;\n    if ( (unsigned __int64)v23 < v20 )\n      break;\n    v27 = *v23;\n    if ( (unsigned int)(*v23 - 48) > 9 )\n    {\n      if ( v13 && (v27 & 0xFFFFFFFD) == 44 )\n      {\n        v28 = v30;\n        if ( v27 != 46 )\n          v28 = v29;\n        *i = v28;\n      }\n      else\n      {\n        *i = v27;\n      }\n    }\n    else\n    {\n      *i = *(_DWORD *)(*v24 + 8LL * (v27 + 3) + 64);\n    }\n  }\n  if ( !v18 )\n  {\n    v31 = i + 1;\n    free(v20);\n    result = v31;\n  }\n  return result;\n}", "signed __int64 __fastcall i18n_number_rewrite_1(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v3; // r13\n  bool v4; // bl\n  __int64 v5; // r14\n  int v6; // eax\n  bool v7; // bl\n  void *v8; // rsp\n  int *v9; // r15\n  int *v10; // rax\n  int *v11; // rax\n  int *v12; // rcx\n  _QWORD *v13; // rsi\n  _DWORD *i; // rdx\n  signed __int64 result; // rax\n  int v16; // er8\n  int v17; // eax\n  int v18; // [rsp-48h] [rbp-48h]\n  int v19; // [rsp-44h] [rbp-44h]\n  __int64 v20; // [rsp-40h] [rbp-40h]\n  __int64 v21; // [rsp-40h] [rbp-40h]\n  signed __int64 v22; // [rsp-40h] [rbp-40h]\n\n  v3 = a2 - a1;\n  v4 = 1;\n  v20 = a3;\n  v5 = wctrans(\"to_outpunct\");\n  v19 = towctrans(46LL, v5);\n  v18 = towctrans(44LL, v5);\n  if ( (unsigned __int64)(a2 - a1) > 0x1000 )\n  {\n    _libc_alloca_cutoff(v3);\n    v4 = v6 != 0;\n  }\n  v7 = v4;\n  if ( v7 )\n  {\n    v8 = alloca(v3 + 15);\n    v9 = (int *)(((unsigned __int64)&v20 + 7) & 0xFFFFFFFFFFFFFFF0LL);\n  }\n  else\n  {\n    malloc(v3);\n    v9 = v10;\n    if ( !v10 )\n      return a1;\n  }\n  mempcpy(v9, a1, v3);\n  v12 = v11;\n  v13 = (_QWORD *)__readfsqword(0xFFFFFFA8);\n  for ( i = (_DWORD *)(v21 - 4); ; --i )\n  {\n    --v12;\n    result = (signed __int64)(i + 1);\n    if ( v12 < v9 )\n      break;\n    v16 = *v12;\n    if ( (unsigned int)(*v12 - 48) > 9 )\n    {\n      if ( v5 && (v16 & 0xFFFFFFFD) == 44 )\n      {\n        v17 = v19;\n        if ( v16 != 46 )\n          v17 = v18;\n        *i = v17;\n      }\n      else\n      {\n        *i = v16;\n      }\n    }\n    else\n    {\n      *i = *(_DWORD *)(*v13 + 8LL * (v16 + 3) + 64);\n    }\n  }\n  if ( !v7 )\n  {\n    v22 = (signed __int64)(i + 1);\n    free(v9);\n    result = v22;\n  }\n  return result;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\npush    r15\npush    r14\npush    r13\nmov     r13, rsi\npush    r12\nmov     r12, rdi\nmov     edi, offset aToOutpunct; \"to_outpunct\"\nsub     r13, r12\npush    rbx\nmov     ebx, 1\nsub     rsp, 18h\nmov     [rbp+var_38], rdx\ncall    wctrans\nmov     edi, 2Eh\nmov     r14, rax\nmov     rsi, rax\ncall    towctrans\nmov     rsi, r14\nmov     edi, 2Ch\nmov     [rbp+var_3C], eax\ncall    towctrans\ncmp     r13, 1000h\nmov     [rbp+var_40], eax\njbe     short loc_401947\nloc_401938:\nmov     rdi, r13\nxor     ebx, ebx\ncall    __libc_alloca_cutoff\ntest    eax, eax\nsetnz   bl\nloc_401947:\nand     bl, 1\njz      short loc_401962\nloc_40194c:\nlea     rdx, [r13+1Eh]\nand     rdx, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rdx\nlea     r15, [rsp+40h+var_38+7]\nand     r15, 0FFFFFFFFFFFFFFF0h\njmp     short loc_401976\nloc_401962:\nmov     rdi, r13\ncall    malloc\ntest    rax, rax\nmov     r15, rax\njz      loc_401A05\nloc_401976:\nmov     rdx, r13\nmov     rsi, r12\nmov     rdi, r15\ncall    mempcpy\nmov     rcx, rax\nmov     rax, 0FFFFFFFFFFFFFFA8h\nmov     rdx, [rbp+var_38]\nmov     rsi, fs:[rax]\nsub     rdx, 4\nloc_40199a:\nsub     rcx, 4\nlea     rax, [rdx+4]\ncmp     rcx, r15\njb      short loc_4019EF\nloc_4019a7:\nmov     r8d, [rcx]\nlea     r9d, [r8-30h]\ncmp     r9d, 9\nja      short loc_4019C7\nloc_4019b4:\nmov     rax, [rsi]\nadd     r8d, 3\nmovsxd  r8, r8d\nmov     eax, [rax+r8*8+40h]\nmov     [rdx], eax\njmp     short loc_4019E9\nloc_4019c7:\ntest    r14, r14\njz      short loc_4019D7\nloc_4019cc:\nmov     eax, r8d\nand     eax, 0FFFFFFFDh\ncmp     eax, 2Ch\njz      short loc_4019DC\nloc_4019d7:\nmov     [rdx], r8d\njmp     short loc_4019E9\nloc_4019dc:\nmov     eax, [rbp+var_3C]\ncmp     r8d, 2Eh\ncmovnz  eax, [rbp+var_40]\nmov     [rdx], eax\nloc_4019e9:\nsub     rdx, 4\njmp     short loc_40199A\nloc_4019ef:\ntest    bl, bl\njnz     short loc_401A08\nloc_4019f3:\nmov     rdi, r15\nmov     [rbp+var_38], rax\ncall    free\nmov     rax, [rbp+var_38]\njmp     short loc_401A08\nloc_401a05:\nmov     rax, r12\nloc_401a08:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn", "push    rbp\nmov     rbp, rsp\npush    r15\npush    r14\npush    r13\nmov     r13, rsi\npush    r12\nmov     r12, rdi\nmov     edi, offset aToOutpunct; \"to_outpunct\"\nsub     r13, r12\npush    rbx\nmov     ebx, 1\nsub     rsp, 18h\nmov     [rbp-38h], rdx\ncall    wctrans\nmov     edi, 2Eh\nmov     r14, rax\nmov     rsi, rax\ncall    towctrans\nmov     rsi, r14\nmov     edi, 2Ch\nmov     [rbp-3Ch], eax\ncall    towctrans\ncmp     r13, 1000h\nmov     [rbp-40h], eax\njbe     short loc_401948\nloc_401939:\nmov     rdi, r13\nxor     ebx, ebx\ncall    __libc_alloca_cutoff\ntest    eax, eax\nsetnz   bl\nloc_401948:\nand     bl, 1\njz      short loc_401963\nloc_40194d:\nlea     rdx, [r13+1Eh]\nand     rdx, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rdx\nlea     r15, [rsp+0Fh]\nand     r15, 0FFFFFFFFFFFFFFF0h\njmp     short loc_401977\nloc_401963:\nmov     rdi, r13\ncall    malloc\ntest    rax, rax\nmov     r15, rax\njz      loc_401A06\nloc_401977:\nmov     rdx, r13\nmov     rsi, r12\nmov     rdi, r15\ncall    mempcpy\nmov     rcx, rax\nmov     rax, 0FFFFFFFFFFFFFFA8h\nmov     rdx, [rbp-38h]\nmov     rsi, fs:[rax]\nsub     rdx, 4\nloc_40199b:\nsub     rcx, 4\nlea     rax, [rdx+4]\ncmp     rcx, r15\njb      short loc_4019F0\nloc_4019a8:\nmov     r8d, [rcx]\nlea     r9d, [r8-30h]\ncmp     r9d, 9\nja      short loc_4019C8\nloc_4019b5:\nmov     rax, [rsi]\nadd     r8d, 3\nmovsxd  r8, r8d\nmov     eax, [rax+r8*8+40h]\nmov     [rdx], eax\njmp     short loc_4019EA\nloc_4019c8:\ntest    r14, r14\njz      short loc_4019D8\nloc_4019cd:\nmov     eax, r8d\nand     eax, 0FFFFFFFDh\ncmp     eax, 2Ch\njz      short loc_4019DD\nloc_4019d8:\nmov     [rdx], r8d\njmp     short loc_4019EA\nloc_4019dd:\nmov     eax, [rbp-3Ch]\ncmp     r8d, 2Eh\ncmovnz  eax, [rbp-40h]\nmov     [rdx], eax\nloc_4019ea:\nsub     rdx, 4\njmp     short loc_40199B\nloc_4019f0:\ntest    bl, bl\njnz     short loc_401A09\nloc_4019f4:\nmov     rdi, r15; void *\nmov     [rbp-38h], rax\ncall    free\nmov     rax, [rbp-38h]\njmp     short loc_401A09\nloc_401a06:\nmov     rax, r12\nloc_401a09:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn"]}, {"ea": "004012ca", "origin name": "group_number", "ea2": "004012cb", "matched name": "group_number", "ratio": "0.970", "bb1": "18", "bb2": "18", "heuristic": "Import names hash", "pseudo": ["_BYTE *__fastcall group_number(_BYTE *a1, _BYTE *a2, char *a3, const char *a4)\n{\n  const char *v4; // r9\n  int v5; // ebx\n  _BYTE *result; // rax\n  int v7; // er12\n  char *v8; // r15\n  void *v9; // rsp\n  unsigned __int64 v10; // r13\n  _BYTE *v11; // rax\n  __int64 v12; // rdi\n  _BYTE *v13; // r8\n  __int64 v14; // rsi\n  char v15; // r9\n  const char *v16; // [rsp+8h] [rbp-38h]\n\n  v4 = a4;\n  v5 = *a3;\n  result = a1;\n  v7 = strlen(a4);\n  if ( (unsigned __int8)(v5 - 1) > 0x7Du )\n    return result;\n  v8 = a3 + 1;\n  v16 = v4;\n  v9 = alloca(a2 - a1 + 15);\n  v10 = ((unsigned __int64)&v16 + 7) & 0xFFFFFFFFFFFFFFF0LL;\n  mempcpy(((unsigned __int64)&v16 + 7) & 0xFFFFFFFFFFFFFFF0LL, a1, a2 - a1);\n  v12 = (__int64)&v16[v7];\n  while ( 1 )\n  {\n    if ( (unsigned __int64)v11 <= v10 )\n      return a2;\n    --v11;\n    --v5;\n    v13 = a2 - 1;\n    *(a2 - 1) = *v11;\n    if ( !v5 && (unsigned __int64)v11 > v10 )\n      break;\nLABEL_15:\n    a2 = v13;\n  }\n  v14 = 0LL;\n  do\n  {\n    v15 = *(_BYTE *)(v12 + v14 - 1);\n    --v13;\n    --v14;\n    *v13 = v15;\n  }\n  while ( (signed int)v14 + v7 > 0 );\n  v5 = *v8;\n  if ( *v8 >= 0 && (_BYTE)v5 != 127 )\n  {\n    if ( (_BYTE)v5 )\n      ++v8;\n    else\n      v5 = *(v8 - 1);\n    goto LABEL_15;\n  }\n  do\n    *--v13 = *--v11;\n  while ( (unsigned __int64)v11 > v10 );\n  return v13;\n}", "_BYTE *__fastcall group_number(_BYTE *a1, _BYTE *a2, char *a3, const char *a4)\n{\n  const char *v4; // r9\n  int v5; // ebx\n  _BYTE *result; // rax\n  int v7; // er12\n  _BYTE *v8; // r15\n  void *v9; // rsp\n  unsigned __int64 v10; // r13\n  _BYTE *v11; // rax\n  const char *v12; // rdi\n  _BYTE *v13; // r8\n  __int64 v14; // rsi\n  char v15; // r9\n  const char *v16; // [rsp-40h] [rbp-40h]\n\n  v4 = a4;\n  v5 = *a3;\n  result = a1;\n  v7 = strlen(a4);\n  if ( (unsigned __int8)(v5 - 1) > 0x7Du )\n    return result;\n  v8 = a3 + 1;\n  v16 = v4;\n  v9 = alloca(a2 - a1 + 15);\n  v10 = ((unsigned __int64)&v16 + 7) & 0xFFFFFFFFFFFFFFF0LL;\n  mempcpy(((unsigned __int64)&v16 + 7) & 0xFFFFFFFFFFFFFFF0LL, a1, a2 - a1);\n  v12 = &v16[v7];\n  while ( 1 )\n  {\n    if ( (unsigned __int64)v11 <= v10 )\n      return a2;\n    --v11;\n    --v5;\n    v13 = a2 - 1;\n    *(a2 - 1) = *v11;\n    if ( !v5 && (unsigned __int64)v11 > v10 )\n      break;\nLABEL_15:\n    a2 = v13;\n  }\n  v14 = 0LL;\n  do\n  {\n    v15 = v12[v14 - 1];\n    --v13;\n    --v14;\n    *v13 = v15;\n  }\n  while ( (signed int)v14 + v7 > 0 );\n  v5 = (char)*v8;\n  if ( *v8 >= 0 && (_BYTE)v5 != 127 )\n  {\n    if ( (_BYTE)v5 )\n      ++v8;\n    else\n      v5 = (char)*(v8 - 1);\n    goto LABEL_15;\n  }\n  do\n    *--v13 = *--v11;\n  while ( (unsigned __int64)v11 > v10 );\n  return v13;\n}"], "asm": ["push    rbp\nmov     r9, rcx\nxor     eax, eax\nmov     r11, rdi\nor      rcx, 0FFFFFFFFFFFFFFFFh\nmov     rdi, r9\nmov     rbp, rsp\npush    r15\npush    r14\npush    r13\npush    r12\npush    rbx\nsub     rsp, 18h\nmovsx   ebx, byte ptr [rdx]\nrepne scasb\nmov     rax, r11\nnot     rcx\nlea     r12, [rcx-1]\nlea     ecx, [rbx-1]\ncmp     cl, 7Dh\nja      loc_4013AF\nloc_401305:\nlea     r15, [rdx+1]\nmov     rdx, rsi\nmov     r14, rsi\nsub     rdx, r11\nmov     rsi, r11\nmov     [rbp+var_38], r9\nlea     rax, [rdx+1Eh]\nand     rax, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rax\nlea     r13, [rsp+40h+var_38+7]\nand     r13, 0FFFFFFFFFFFFFFF0h\nmov     rdi, r13\ncall    mempcpy\nmov     r9, [rbp+var_38]\nmovsxd  rdi, r12d\nmov     rsi, r14\nadd     rdi, r9\nloc_401342:\ncmp     rax, r13\njbe     short loc_4013A7\nloc_401347:\ndec     rax\nmov     dl, [rax]\ndec     ebx\nlea     r8, [rsi-1]\nmov     [rsi-1], dl\njnz     short loc_4013A2\nloc_401357:\ncmp     rax, r13\njbe     short loc_4013A2\nloc_40135c:\nxor     esi, esi\nloc_40135e:\nmov     r9b, [rdi+rsi-1]\ndec     r8\ndec     rsi\nmov     [r8], r9b\nlea     r9d, [rsi+r12]\ntest    r9d, r9d\njg      short loc_40135E\nloc_401375:\nmovsx   ebx, byte ptr [r15]\ntest    bl, bl\njs      short loc_401382\nloc_40137d:\ncmp     bl, 7Fh\njnz     short loc_401394\nloc_401382:\ndec     rax\nmov     dl, [rax]\ndec     r8\ncmp     rax, r13\nmov     [r8], dl\nja      short loc_401382\nloc_401392:\njmp     short loc_4013AC\nloc_401394:\ntest    bl, bl\njz      short loc_40139D\nloc_401398:\ninc     r15\njmp     short loc_4013A2\nloc_40139d:\nmovsx   ebx, byte ptr [r15-1]\nloc_4013a2:\nmov     rsi, r8\njmp     short loc_401342\nloc_4013a7:\nmov     rax, rsi\njmp     short loc_4013AF\nloc_4013ac:\nmov     rax, r8\nloc_4013af:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn", "push    rbp\nmov     r9, rcx\nxor     eax, eax\nmov     r11, rdi\nor      rcx, 0FFFFFFFFFFFFFFFFh\nmov     rdi, r9\nmov     rbp, rsp\npush    r15\npush    r14\npush    r13\npush    r12\npush    rbx\nsub     rsp, 18h\nmovsx   ebx, byte ptr [rdx]\nrepne scasb\nmov     rax, r11\nnot     rcx\nlea     r12, [rcx-1]\nlea     ecx, [rbx-1]\ncmp     cl, 7Dh\nja      loc_4013B0\nloc_401306:\nlea     r15, [rdx+1]\nmov     rdx, rsi\nmov     r14, rsi\nsub     rdx, r11\nmov     rsi, r11\nmov     [rbp-38h], r9\nlea     rax, [rdx+1Eh]\nand     rax, 0FFFFFFFFFFFFFFF0h\nsub     rsp, rax\nlea     r13, [rsp+0Fh]\nand     r13, 0FFFFFFFFFFFFFFF0h\nmov     rdi, r13\ncall    mempcpy\nmov     r9, [rbp-38h]\nmovsxd  rdi, r12d\nmov     rsi, r14\nadd     rdi, r9\nloc_401343:\ncmp     rax, r13\njbe     short loc_4013A8\nloc_401348:\ndec     rax\nmov     dl, [rax]\ndec     ebx\nlea     r8, [rsi-1]\nmov     [rsi-1], dl\njnz     short loc_4013A3\nloc_401358:\ncmp     rax, r13\njbe     short loc_4013A3\nloc_40135d:\nxor     esi, esi\nloc_40135f:\nmov     r9b, [rdi+rsi-1]\ndec     r8\ndec     rsi\nmov     [r8], r9b\nlea     r9d, [rsi+r12]\ntest    r9d, r9d\njg      short loc_40135F\nloc_401376:\nmovsx   ebx, byte ptr [r15]\ntest    bl, bl\njs      short loc_401383\nloc_40137e:\ncmp     bl, 7Fh\njnz     short loc_401395\nloc_401383:\ndec     rax\nmov     dl, [rax]\ndec     r8\ncmp     rax, r13\nmov     [r8], dl\nja      short loc_401383\nloc_401393:\njmp     short loc_4013AD\nloc_401395:\ntest    bl, bl\njz      short loc_40139E\nloc_401399:\ninc     r15\njmp     short loc_4013A3\nloc_40139e:\nmovsx   ebx, byte ptr [r15-1]\nloc_4013a3:\nmov     rsi, r8\njmp     short loc_401343\nloc_4013a8:\nmov     rax, rsi\njmp     short loc_4013B0\nloc_4013ad:\nmov     rax, r8\nloc_4013b0:\nlea     rsp, [rbp-28h]\npop     rbx\npop     r12\npop     r13\npop     r14\npop     r15\npop     rbp\nretn"]}, {"ea": "00405a12", "origin name": "fchmod_or_lchmod", "ea2": "00403a30", "matched name": "fchmod_or_lchmod", "ratio": "0.560", "bb1": "4", "bb2": "5", "heuristic": "Similar pseudo-code and names", "pseudo": ["__int64 __fastcall fchmod_or_lchmod(unsigned int a1, __int64 a2, unsigned int a3)\n{\n  __int64 result; // rax\n\n  if ( (a1 & 0x80000000) != 0 )\n    result = chmod();\n  else\n    result = fchmod();\n  return result;\n}", "int __fastcall fchmod_or_lchmod(int desc, const char *name, mode_t mode)\n{\n  int result; // eax\n\n  if ( desc < 0 )\n    result = chmod(name, mode);\n  else\n    result = fchmod(desc, mode);\n  return result;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\nsub     rsp, 10h\nmov     [rbp+var_4], edi\nmov     [rbp+var_10], rsi\nmov     [rbp+var_8], edx\ncmp     [rbp+var_4], 0\njs      short loc_405A3B\nloc_405a2a:\nmov     edx, [rbp+var_8]\nmov     eax, [rbp+var_4]\nmov     esi, edx\nmov     edi, eax\ncall    fchmod\njmp     short locret_405A4C\nloc_405a3b:\nmov     edx, [rbp+var_8]\nmov     rax, [rbp+var_10]\nmov     esi, edx\nmov     rdi, rax\ncall    chmod\nloc_405a4c:\nleave\nretn", "test    edi, edi\nmov     rax, name\nmov     esi, edx\njs      short loc_403A40\nloc_403a39:\njmp     fchmod\nloc_403a40:\nmov     desc, name\njmp     chmod\nloc_460930:\nmov     eax, 5Ah; Alternative name is '__chmod'\nloc_460950:\nmov     eax, 5Bh; Alternative name is '__fchmod'"]}], "unreliable matching": [{"ea": "00402d53", "origin name": "target_directory_operand", "ea2": "00402650", "matched name": "target_directory_operand", "ratio": "0.410", "bb1": "12", "bb2": "10", "heuristic": "Same constants", "pseudo": ["_BOOL8 __fastcall target_directory_operand(__int64 a1, __int64 a2, _BYTE *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)\n{\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  unsigned int v13; // eax\n  bool v14; // al\n  unsigned int *v15; // rbx\n  const __m128i *v16; // rax\n  _BYTE *v18; // [rsp+8h] [rbp-38h]\n  bool v19; // [rsp+2Bh] [rbp-15h]\n  unsigned int v20; // [rsp+2Ch] [rbp-14h]\n\n  v18 = a3;\n  if ( (unsigned int)stat(a1, a2) )\n    v13 = *(_DWORD *)_errno_location();\n  else\n    v13 = 0;\n  v20 = v13;\n  v14 = !v13 && (*(_DWORD *)(a2 + 24) & 0xF000) == 0x4000;\n  v19 = v14;\n  if ( v20 )\n  {\n    if ( v20 != 2 )\n    {\n      v15 = quotearg_style(4, a1, a4, a5, a6, a7, v11, v12, a10, a11);\n      v16 = (const __m128i *)gettext((__int64)\"failed to access %s\");\n      error(1u, v20, v16, v15);\n    }\n    *v18 = 1;\n  }\n  return v19;\n}", "_Bool __fastcall target_directory_operand(const char *file, stat *st, _Bool *new_dst, _Bool forcing)\n{\n  _Bool *v4; // r14\n  _Bool v5; // r13\n  unsigned int v6; // er12\n  _Bool result; // al\n  char *v8; // rbx\n  __int64 v9; // rax\n  const char *v10; // rdx\n  dir_attr **v11; // rcx\n  _Bool *v12; // r8\n  const cp_options *v13; // r9\n\n  v4 = new_dst;\n  v5 = forcing;\n  if ( !(unsigned int)xstat(1LL, file, st) )\n    return (st->st_mode & 0xF000) == 0x4000;\n  v6 = *(_DWORD *)_errno_location(1LL);\n  if ( !v6 )\n    return (st->st_mode & 0xF000) == 0x4000;\n  if ( v6 == 2 )\n  {\n    *v4 = 1;\n    result = 0;\n  }\n  else if ( v5 )\n  {\n    st->st_mode = 0;\n    result = 0;\n  }\n  else\n  {\n    v8 = quotearg_style(shell_escape_always_quoting_style, file);\n    v9 = dcgettext(0LL, \"failed to access %s\", 5LL);\n    error(1LL, v6, v9, v8);\n    result = make_dir_parents_private((const char *)1, v6, v10, v11, v12, v13);\n  }\n  return result;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\npush    rbx\nsub     rsp, 38h\nmov     [rbp+var_28], rdi\nmov     [rbp+var_30], rsi\nmov     [rbp+var_38], rdx\nmov     rdx, [rbp+var_30]\nmov     rax, [rbp+var_28]\nmov     rsi, rdx\nmov     rdi, rax\ncall    stat\ntest    eax, eax\njz      short loc_402D88\nloc_402d7f:\ncall    __errno_location\nmov     eax, [rax]\njmp     short loc_402D8D\nloc_402d88:\nmov     eax, 0\nloc_402d8d:\nmov     [rbp+var_14], eax\ncmp     [rbp+var_14], 0\njnz     short loc_402DB0\nloc_402d96:\nmov     rax, [rbp+var_30]\nmov     eax, [rax+18h]\nand     eax, 0F000h\ncmp     eax, 4000h\njnz     short loc_402DB0\nloc_402da9:\nmov     eax, 1\njmp     short loc_402DB5\nloc_402db0:\nmov     eax, 0\nloc_402db5:\nmov     [rbp+var_15], al\nand     [rbp+var_15], 1\ncmp     [rbp+var_14], 0\njz      short loc_402E09\nloc_402dc2:\ncmp     [rbp+var_14], 2\njz      short loc_402E02\nloc_402dc8:\nmov     rax, [rbp+var_28]\nmov     rsi, rax\nmov     edi, 4\ncall    quotearg_style\nmov     rbx, rax\nlea     rdi, aFailedToAccess; \"failed to access %s\"\ncall    gettext\nmov     rdx, rax\nmov     eax, [rbp+var_14]\nmov     rcx, rbx\nmov     esi, eax\nmov     edi, 1\nmov     eax, 0\ncall    error\nloc_402e02:\nmov     rax, [rbp+var_38]\nmov     byte ptr [rax], 1\nloc_402e09:\nmovzx   eax, [rbp+var_15]\nadd     rsp, 38h\npop     rbx\npop     rbp\nretn", "push    r14\nmov     r14, new_dst\nmov     new_dst, st\npush    r13\nmov     r13d, ecx\npush    r12\npush    rbp\nmov     rbp, file\npush    rbx\nmov     rbx, st\nmov     st, file\nmov     edi, 1\ncall    _xstat\ntest    eax, eax\njz      short loc_40269B\nloc_402678:\ncall    __errno_location\nmov     r12d, [rax]\ntest    r12d, r12d\njz      short loc_40269B\nloc_402685:\ncmp     r12d, 2\njz      short loc_4026B4\nloc_40268b:\ntest    r13b, r13b\njz      short loc_4026BC\nloc_402690:\nmov     dword ptr [st+18h], 0\nxor     eax, eax\njmp     short loc_4026AB\nloc_40269b:\nmov     eax, [st+18h]\nand     eax, 0F000h\ncmp     eax, 4000h\nsetz    al\nloc_4026ab:\npop     st\npop     file\npop     r12\npop     r13\npop     new_dst\nretn\nloc_4026b4:\nmov     byte ptr [new_dst], 1\nxor     eax, eax\njmp     short loc_4026AB\nloc_4026bc:\nmov     rsi, file; arg\nmov     edi, 4; s\ncall    quotearg_style\nmov     edx, 5\nmov     st, rax\nmov     esi, offset aFailedToAccess; \"failed to access %s\"\nxor     edi, edi\ncall    dcgettext\nmov     rcx, rbx\nmov     rdx, rax\nmov     esi, r12d\nmov     edi, 1\nxor     eax, eax\ncall    error\nnop     word ptr [rax+rax+00000000h]\nloc_402700:\npush    rbp"]}, {"ea": "00405902", "origin name": "set_file_security_ctx", "ea2": "004042c0", "matched name": "set_file_security_ctx", "ratio": "0.240", "bb1": "16", "bb2": "4", "heuristic": "Same constants", "pseudo": ["signed __int64 __fastcall set_file_security_ctx(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)\n{\n  bool v12; // al\n  bool v13; // al\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  int *v16; // rax\n  unsigned int *v17; // r12\n  const __m128i *v18; // rbx\n  unsigned int *v19; // rax\n  bool v21; // [rsp+2Eh] [rbp-12h]\n  bool v22; // [rsp+2Fh] [rbp-11h]\n\n  v12 = a4[35] != 1 || a4[38];\n  v21 = v12;\n  v13 = !v12 && a4[41] != 1;\n  v22 = v13;\n  if ( !((unsigned __int8)restorecon(a1) ^ 1) )\n    return 1LL;\n  if ( v21 || v22 && (v16 = (int *)_errno_location(), (unsigned __int8)errno_unsupported(*v16) ^ 1) )\n  {\n    v17 = quotearg_n_style(0, 4, a1, a5, a6, a7, a8, v14, v15, a11, a12);\n    v18 = (const __m128i *)gettext((__int64)\"failed to set the security context of %s\");\n    v19 = (unsigned int *)_errno_location();\n    error(0, *v19, v18, v17);\n  }\n  return 0LL;\n}", "_Bool __fastcall set_file_security_ctx(const char *dst_name, _Bool process_local, _Bool recurse, const cp_options *x)\n{\n  _DWORD *v4; // rax\n  unsigned int *v5; // rbx\n  char *v6; // rbp\n  __int64 v7; // rax\n  _Bool result; // al\n\n  if ( x->data_copy_required && !x->require_preserve_context )\n  {\n    *(_DWORD *)_errno_location(dst_name) = 95;\n    result = 0;\n  }\n  else\n  {\n    v4 = (_DWORD *)_errno_location(dst_name);\n    *v4 = 95;\n    v5 = v4;\n    v6 = quotearg_n_style(0, shell_escape_always_quoting_style, dst_name);\n    v7 = dcgettext(0LL, \"failed to set the security context of %s\", 5LL);\n    error(0LL, *v5, v7, v6);\n    result = 0;\n  }\n  return result;\n}"], "asm": ["push    rbp\nmov     rbp, rsp\npush    r12\npush    rbx\nsub     rsp, 30h\nmov     [rbp+var_28], rdi\nmov     eax, edx\nmov     [rbp+var_38], rcx\nmov     [rbp+var_2C], sil\nmov     [rbp+var_30], al\nmov     rax, [rbp+var_38]\nmovzx   eax, byte ptr [rax+23h]\nxor     eax, 1\ntest    al, al\njnz     short loc_405939\nloc_40592d:\nmov     rax, [rbp+var_38]\nmovzx   eax, byte ptr [rax+26h]\ntest    al, al\njz      short loc_405940\nloc_405939:\nmov     eax, 1\njmp     short loc_405945\nloc_405940:\nmov     eax, 0\nloc_405945:\nmov     [rbp+var_12], al\nand     [rbp+var_12], 1\nmovzx   eax, [rbp+var_12]\nxor     eax, 1\ntest    al, al\njz      short loc_40596D\nloc_405957:\nmov     rax, [rbp+var_38]\nmovzx   eax, byte ptr [rax+29h]\nxor     eax, 1\ntest    al, al\njz      short loc_40596D\nloc_405966:\nmov     eax, 1\njmp     short loc_405972\nloc_40596d:\nmov     eax, 0\nloc_405972:\nmov     [rbp+var_11], al\nand     [rbp+var_11], 1\nmovzx   edx, [rbp+var_2C]\nmovzx   ecx, [rbp+var_30]\nmov     rax, [rbp+var_28]\nmov     esi, ecx\nmov     rdi, rax\ncall    restorecon\nxor     eax, 1\ntest    al, al\njz      short loc_405A04\nloc_405996:\ncmp     [rbp+var_12], 0\njnz     short loc_4059B7\nloc_40599c:\ncmp     [rbp+var_11], 0\njz      short loc_4059FD\nloc_4059a2:\ncall    __errno_location\nmov     eax, [rax]\nmov     edi, eax\ncall    errno_unsupported\nxor     eax, 1\ntest    al, al\njz      short loc_4059FD\nloc_4059b7:\nmov     rax, [rbp+var_28]\nmov     rdx, rax\nmov     esi, 4\nmov     edi, 0\ncall    quotearg_n_style\nmov     r12, rax\nlea     rdi, aFailedToSetThe; \"failed to set the security context of %\"...\ncall    gettext\nmov     rbx, rax\ncall    __errno_location\nmov     eax, [rax]\nmov     rcx, r12\nmov     rdx, rbx\nmov     esi, eax\nmov     edi, 0\nmov     eax, 0\ncall    error\nloc_4059fd:\nmov     eax, 0\njmp     short loc_405A09\nloc_405a04:\nmov     eax, 1\nloc_405a09:\nadd     rsp, 30h\npop     rbx\npop     r12\npop     rbp\nretn", "push    rbp\nmov     rbp, dst_name\npush    rbx\nsub     rsp, 8\ncmp     byte ptr [x+23h], 0\njz      short loc_4042D5\nloc_4042cf:\ncmp     byte ptr [x+26h], 0\njz      short loc_404320\nloc_4042d5:\ncall    __errno_location\nmov     rdx, dst_name; arg\nmov     esi, 4; s\nxor     edi, edi; n\nmov     dword ptr [rax], 5Fh\nmov     rbx, rax\ncall    quotearg_n_style\nmov     edx, 5\nmov     esi, offset aFailedToSetThe; \"failed to set the security context of %\"...\nxor     edi, edi\nmov     dst_name, rax\ncall    dcgettext\nmov     esi, [rbx]\nmov     rcx, rbp\nmov     rdx, rax\nxor     edi, edi\nxor     eax, eax\ncall    error\nadd     rsp, 8\nxor     eax, eax\npop     rbx\npop     rbp\nretn\nloc_404320:\ncall    __errno_location\nmov     dword ptr [rax], 5Fh\nadd     rsp, 8\nxor     eax, eax\npop     rbx\npop     dst_name\nretn"]}, {"ea": "00407457", "origin name": "emit_verbose", "ea2": "00403a50", "matched name": "emit_verbose", "ratio": "0.340", "bb1": "3", "bb2": "6", "heuristic": "Same constants", "pseudo": ["__int64 __fastcall emit_verbose(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)\n{\n  unsigned int *v11; // rbx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  unsigned int *v14; // rax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned int *v17; // rbx\n  char *v18; // rax\n  __int64 v20; // [rsp+8h] [rbp-28h]\n\n  v20 = a3;\n  v11 = quotearg_n_style(1u, 4, a2, a4, a5, a6, a7, a8, a9, a10, a11);\n  v14 = quotearg_n_style(0, 4, a1, a4, a5, a6, a7, v12, v13, a10, a11);\n  printf((__int64)\"%s -> %s\", v14, v11);\n  if ( v20 )\n  {\n    v17 = quotearg_style(4, v20, a4, a5, a6, a7, v15, v16, a10, a11);\n    v18 = gettext((__int64)\" (backup: %s)\");\n    printf((__int64)v18, v17);\n  }\n  return putchar_unlocked(0xAu);\n}", "void __fastcall emit_verbose(const char *src, const char *dst, const char *backup_dst_name)\n{\n  const char *v3; // rbx\n  char *v4; // r12\n  char *v5; // rax\n  char *v6; // rbx\n  __int64 v7; // rax\n  __int64 v8; // rcx\n  char *v9; // rax\n\n  v3 = backup_dst_name;\n  v4 = quotearg_n_style(1, shell_escape_always_quoting_style, dst);\n  v5 = quotearg_n_style(0, shell_escape_always_quoting_style, src);\n  _printf_chk(1LL, \"%s -> %s\", v5, v4);\n  if ( v3 )\n  {\n    v6 = quotearg_style(shell_escape_always_quoting_style, v3);\n    v7 = dcgettext(0LL, \" (backup: %s)\", 5LL);\n    _printf_chk(1LL, v7, v6, v8);\n  }\n  v9 = stdout->_IO_write_ptr;\n  if ( v9 >= stdout->_IO_write_end )\n  {\n    _overflow(stdout, 10LL);\n  }\n  else\n  {\n    stdout->_IO_write_ptr = v9 + 1;\n    *v9 = 10;\n  }\n}"], "asm": ["push    rbp\nmov     rbp, rsp\npush    rbx\nsub     rsp, 28h\nmov     [rbp+var_18], rdi\nmov     [rbp+var_20], rsi\nmov     [rbp+var_28], rdx\nmov     rax, [rbp+var_20]\nmov     rdx, rax\nmov     esi, 4\nmov     edi, 1\ncall    quotearg_n_style\nmov     rbx, rax\nmov     rax, [rbp+var_18]\nmov     rdx, rax\nmov     esi, 4\nmov     edi, 0\ncall    quotearg_n_style\nmov     rdx, rbx\nmov     rsi, rax\nlea     rdi, aSS_0; \"%s -> %s\"\nmov     eax, 0\ncall    printf\ncmp     [rbp+var_28], 0\njz      short loc_4074E9\nloc_4074b9:\nmov     rax, [rbp+var_28]\nmov     rsi, rax\nmov     edi, 4\ncall    quotearg_style\nmov     rbx, rax\nlea     rdi, aBackupS; \" (backup: %s)\"\ncall    gettext\nmov     rsi, rbx\nmov     rdi, rax\nmov     eax, 0\ncall    printf\nloc_4074e9:\nmov     edi, 0Ah\ncall    putchar_unlocked\nadd     rsp, 28h\npop     rbx\npop     rbp\nretn", "push    r12\npush    rbp\nmov     rbp, src\nmov     edi, 1; n\npush    rbx\nmov     rbx, backup_dst_name\nmov     backup_dst_name, dst; arg\nmov     esi, 4; s\ncall    quotearg_n_style\nxor     edi, edi; n\nmov     r12, rax\nmov     rdx, src; arg\nmov     esi, 4; s\ncall    quotearg_n_style\nmov     rcx, r12\nmov     rdx, rax\nmov     esi, offset aSS_0; \"%s -> %s\"\nxor     eax, eax\nmov     edi, 1\ncall    __printf_chk\ntest    backup_dst_name, backup_dst_name\njz      short loc_403ACD\nloc_403a9a:\nmov     rsi, backup_dst_name; arg\nmov     edi, 4; s\ncall    quotearg_style\nmov     edx, 5\nmov     backup_dst_name, rax\nmov     esi, offset aBackupS; \" (backup: %s)\"\nxor     edi, edi\ncall    dcgettext\nmov     rdx, rbx\nmov     rsi, rax\nmov     edi, 1\nxor     eax, eax\ncall    __printf_chk\nloc_403acd:\nmov     rdi, cs:stdout\nmov     rax, [rdi+28h]\ncmp     rax, [rdi+30h]\njnb     short loc_403AEE\nloc_403ade:\nlea     rdx, [rax+1]\nmov     [rdi+28h], rdx\nmov     byte ptr [rax], 0Ah\npop     rbx\npop     src\npop     r12\nretn\nloc_403aee:\npop     rbx\npop     src\npop     r12\nmov     esi, 0Ah\njmp     __overflow\nloc_421e20:\nmov     eax, [rdi+0C0h]"]}], "vulnerable matching": [], "statistics": [{"matched": 19, "unmatched": 22}, {"best matching": 11, "partial matching": 5, "unreliable matching": 3, "vulnerable matching": 0}]}